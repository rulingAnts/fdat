<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FLEx XML Viewer</title>
<style>
  :root{
    --accent:#0b6edb;
    --muted:#6c6c6c;
    --bg:#fbfbfb;
    --card:#fff;
    --border:#e2e2e2;
    --highlight:#fff2b8;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; margin:18px; background:var(--bg); color:#111}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:1.1rem;margin:0}
  textarea{width:720px;max-width:100%;height:220px;font-family:monospace;padding:8px;border:1px solid var(--border);border-radius:6px;background:linear-gradient(#fff,#fcfcfc)}
  input[type=file]{padding:6px}
  button{background:var(--accent);color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#ddd;color:#111}
  .small-btn{padding:3px 6px;font-size:0.85rem;border-radius:5px}
  .viewer{margin-top:18px;background:var(--card);border:1px solid var(--border);padding:14px;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  .controls-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .section-title{font-weight:600;margin:8px 0;font-size:1rem}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  ul.tree li{margin:4px 0;position:relative;padding-left:6px}
  .toggle{user-select:none;cursor:pointer;margin-right:6px;color:var(--accent)}
  .collapsed > ul{display:none}
  .label{font-weight:600;margin-right:6px}
  .muted{color:var(--muted);font-size:0.95rem}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  tr.highlight{background:var(--highlight) !important}
  .natclass{border:1px solid var(--border);padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
  .natclass .members{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .symbol-pill:hover{background:#e8f2ff}
  .small-muted{font-size:0.9rem;color:var(--muted)}
  .translation-main{font-weight:600}
  .translation-others{color:var(--muted);margin-left:6px;font-size:0.95rem}
  .lang-controls{display:flex;align-items:center;gap:8px;margin:6px 0 12px 0}
  .lang-controls .lang-item{display:flex;align-items:center;gap:6px;padding:4px}
  .icon-btn{background:#f5f5f5;border:1px solid #e0e0e0;padding:4px 6px;border-radius:6px;cursor:pointer}
  footer{margin-top:28px;padding-top:10px;border-top:1px solid #e6e6e6;color:var(--muted);font-size:0.9rem}
</style>
</head>
<body>
<header>
  <h1>FLEx XML Viewer</h1>
  <div class="muted small-muted" style="margin-left:auto">© 2025 Seth Johnston</div>
</header>

<textarea id="xmlInput" placeholder="Paste XML here or choose a file..."></textarea>

<div class="controls-row">
  <button id="transformBtn">Transform</button>
  <button id="resetBtn" class="secondary">Reset</button>
  <label style="display:flex;align-items:center;gap:8px" class="small-muted">
    <input id="showNames" type="checkbox"> Show element names
  </label>
  <div style="margin-left:auto;display:flex;gap:8px">
    <input id="fileInput" type="file" accept=".xml,.xml.txt" />
    <button id="openBtn" class="secondary">Open in new window</button>
    <button id="saveBtn" class="secondary">Save as HTML</button>
  </div>
</div>

<div id="viewer" class="viewer" aria-live="polite">
  <div id="renderArea" class="small-muted">Paste or upload an XML file, then click Transform.</div>
</div>

<!-- Footer / license -->
<footer>
  <div>© 2025 Seth Johnston. This software is licensed under the <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" rel="noopener noreferrer">GNU Affero General Public License v3.0 (AGPL-3.0)</a>.</div>
  <div>Portions of this code were generated collaboratively with <strong>ChatGPT (GPT-5)</strong> by OpenAI under the author’s direction and guidance.</div>
</footer>

<script>
/* ===== Helpers ===== */
const byId = id => document.getElementById(id);
const escapeHtml = s => String(s||'').replace(/[&<>"]/g, c=>'&' + ({'&':'amp','<':'lt','>':'gt','"':'quot'})[c] + ';');
function create(tag, attrs={}, text){
  const el = document.createElement(tag);
  for(const k in attrs){
    if(k==='cls') el.className = attrs[k];
    else el.setAttribute(k, attrs[k]);
  }
  if(text !== undefined && text !== null) el.textContent = text;
  return el;
}

/* ===== Global state & localStorage helpers ===== */
const LANG_PREFS_KEY = 'flex_xml_viewer_lang_prefs_v1';
let globalState = {
  phonemeIndex: {},
  idToNatclassIds: {},
  natclassElements: {},
  phonemeRowIds: {},
  showNames: false
};

function saveLangPrefs(prefs){
  try{ localStorage.setItem(LANG_PREFS_KEY, JSON.stringify(prefs)); } catch(e){}
}
function loadLangPrefs(){
  try{ const s = localStorage.getItem(LANG_PREFS_KEY); return s ? JSON.parse(s) : null; } catch(e){ return null; }
}

/* ===== File & UI wiring ===== */
byId('fileInput').addEventListener('change', async e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  byId('xmlInput').value = text;
});

byId('resetBtn').addEventListener('click', ()=>{
  byId('xmlInput').value = '';
  byId('renderArea').innerHTML = '<div class="small-muted">Paste or upload an XML file, then click Transform.</div>';
});

byId('transformBtn').addEventListener('click', ()=> {
  const xmlText = byId('xmlInput').value.trim();
  if(!xmlText){ alert('Please paste or upload an XML document first.'); return; }
  try {
    const p = new DOMParser();
    const xmlDoc = p.parseFromString(xmlText, 'application/xml');
    if(xmlDoc.querySelector('parsererror')) throw new Error('XML parse error');
    renderDocument(xmlDoc);
  } catch(err){
    alert('Error parsing XML: ' + err.message);
  }
});

byId('openBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML();
  const w = window.open('', '_blank');
  w.document.write(html);
  w.document.close();
});

byId('saveBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML();
  const blob = new Blob([html], {type:'text/html'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'flex_xml_view.html';
  a.click();
  URL.revokeObjectURL(a.href);
});

byId('showNames').addEventListener('change', e=>{
  globalState.showNames = e.target.checked;
  document.querySelectorAll('[data-gen-label]').forEach(el=>{
    const label = el.getAttribute('data-gen-label');
    const prev = el.previousSibling;
    if(prev) prev.textContent = globalState.showNames ? (label + ': ') : '';
  });
});

/* ===== Main detection & dispatch ===== */
function renderDocument(xmlDoc){
  // reset state
  globalState = { phonemeIndex:{}, idToNatclassIds:{}, natclassElements:{}, phonemeRowIds:{}, showNames: byId('showNames').checked };

  const root = xmlDoc.documentElement;
  const tag = root.nodeName.toLowerCase();
  const area = byId('renderArea');
  area.innerHTML = '';

  if(tag === 'list' || tag === 'lists'){
    // detect AUni-based multilingual lists
    const aunis = xmlDoc.querySelectorAll('AUni[ws]');
    const langSet = new Set(Array.from(aunis).map(a => a.getAttribute('ws')));
    if(langSet.size > 1){
      area.appendChild(renderTranslatedListView(root, Array.from(langSet)));
      return;
    } else {
      area.appendChild(renderListView(root));
      return;
    }
  }

  if(tag === 'phonology'){
    area.appendChild(renderPhonologyView(xmlDoc));
    return;
  }

  // fallback generic
  area.appendChild(renderGenericView(root));
}

/* ===== Monolingual List (unchanged behavior) ===== */
function renderListView(root){
  const container = create('div');
  const title = root.querySelector(':scope > name, :scope > Name')?.textContent?.trim() || 'List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  function buildItem(node){
    const li = create('li');
    const hasChildren = node.querySelector(':scope > item') !== null;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '▾' : ' ');
    if(hasChildren) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const name = node.querySelector(':scope > name, :scope > Name')?.textContent?.trim() || node.nodeName;
    const abbr = node.querySelector(':scope > abbr, :scope > Abbreviation')?.textContent?.trim();
    const text = abbr ? `${name} (${abbr})` : name;
    li.appendChild(document.createTextNode(text));

    const childItems = Array.from(node.children).filter(c=>c.nodeName === 'item' || c.nodeName === 'Item');
    if(childItems.length){
      const ul = create('ul', {cls:'tree'});
      childItems.forEach(ci => ul.appendChild(buildItem(ci)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
      });
    }
    return li;
  }

  const topUL = create('ul', {cls:'tree'});
  const topItems = Array.from(root.children).filter(c => c.nodeName.toLowerCase() === 'item');
  topItems.forEach(it => topUL.appendChild(buildItem(it)));
  container.appendChild(topUL);
  return container;
}

/* ===== Translated (multilingual) List view + Language Controls ===== */
function renderTranslatedListView(root, langList){
  // canonicalize languages (stable order): try to prefer 'en' first if present
  const langs = Array.from(langList);
  langs.sort((a,b)=>{
    if(a.toLowerCase().includes('en') && !b.toLowerCase().includes('en')) return -1;
    if(b.toLowerCase().includes('en') && !a.toLowerCase().includes('en')) return 1;
    return a.localeCompare(b);
  });

  // load saved prefs and merge defaults
  const saved = loadLangPrefs() || {};
  const prefs = {};
  langs.forEach((ws,i)=> {
    prefs[ws] = {
      ws,
      order: (saved[ws] && typeof saved[ws].order === 'number') ? saved[ws].order : i,
      visible: (saved[ws] && typeof saved[ws].visible === 'boolean') ? saved[ws].visible : true
    };
  });
  // ensure order indices are compact 0..n-1 by sort
  const orderedLangs = Object.values(prefs).sort((a,b)=>a.order - b.order).map(l=>l.ws);
  orderedLangs.forEach((ws,i)=> prefs[ws].order = i);
  saveLangPrefs(prefs);

  const container = create('div');
  const title = root.querySelector(':scope > Name AUni[ws="en"], :scope > Name AUni, :scope > Name, :scope > name')?.textContent?.trim() || 'Translated List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  // language controls (Option A: inline under title)
  const controls = create('div', {cls:'lang-controls'});
  container.appendChild(controls);

  function buildLangControls(){
    controls.innerHTML = ''; // refresh
    // sort by order
    const arr = Object.values(prefs).sort((a,b)=>a.order-b.order);
    arr.forEach((L, idx)=>{
      const item = create('div', {cls:'lang-item'});
      item.style.display = 'flex'; item.style.alignItems = 'center'; item.style.gap = '6px';

      const codeSpan = create('span', {}, L.ws);
      codeSpan.style.fontWeight = '600';
      item.appendChild(codeSpan);

      // Up
      const up = create('button', {cls:'icon-btn', title:'Move up (higher priority)'}, '⬆️');
      up.addEventListener('click', ()=> { swapOrder(L.ws, -1); });
      item.appendChild(up);

      // Down
      const down = create('button', {cls:'icon-btn', title:'Move down (lower priority)'}, '⬇️');
      down.addEventListener('click', ()=> { swapOrder(L.ws, +1); });
      item.appendChild(down);

      // Toggle visibility
      const vis = create('button', {cls:'icon-btn', title: L.visible ? 'Hide language' : 'Show language'}, L.visible ? '👁️' : '🚫');
      vis.addEventListener('click', ()=> { prefs[L.ws].visible = !prefs[L.ws].visible; saveLangPrefs(prefs); buildLangControls(); renderItems(); });
      item.appendChild(vis);

      controls.appendChild(item);
    });

    // reset button
    const reset = create('button', {cls:'small-btn secondary', title:'Reset language order and visibility to defaults'}, 'Reset');
    reset.addEventListener('click', ()=> {
      // restore default order (= initial langs) and visible=true
      langs.forEach((ws,i)=> { prefs[ws].order = i; prefs[ws].visible = true; });
      saveLangPrefs(prefs); buildLangControls(); renderItems();
    });
    controls.appendChild(reset);
  }

  // build list container
  const listContainer = create('div');
  container.appendChild(listContainer);

  function renderItems(){
    listContainer.innerHTML = '';
    // build ordered visible langs array
    const ordered = Object.values(prefs).sort((a,b)=>a.order-b.order).filter(l=>l.visible).map(l=>l.ws);
    // if none visible, show message
    if(ordered.length === 0){
      listContainer.appendChild(create('div', {cls:'small-muted'}, 'No languages selected. Use controls to show at least one language.'));
      return;
    }
    // top-level possibilities container
    const poss = root.querySelector(':scope > Possibilities, :scope > possibilities') || root;
    const topItems = Array.from(poss.children).filter(c=>c.nodeType === 1);
    const topUL = create('ul', {cls:'tree'});
    topItems.forEach(ti => topUL.appendChild(buildItem(ti, ordered)));
    listContainer.appendChild(topUL);
  }

  function buildItem(node, visibleLangs){
    const li = create('li');
    const sub = node.querySelector(':scope > SubPossibilities, :scope > SubPossibility, :scope > Possibilities');
    const hasSub = sub && Array.from(sub.children).some(c=>c.nodeType === 1);
    const toggle = create('span', {cls:'toggle'}, hasSub ? '▾' : ' ');
    if(hasSub) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const nameNode = node.querySelector(':scope > Name, :scope > name');
    const abbrNode = node.querySelector(':scope > Abbreviation, :scope > abbr');
    const names = collectAUniMap(nameNode);
    const abbrs = collectAUniMap(abbrNode);
    const inline = create('span');
    inline.innerHTML = buildMultilingualInlineHTML(names, abbrs, visibleLangs);
    li.appendChild(inline);

    if(hasSub){
      const ul = create('ul', {cls:'tree'});
      Array.from(sub.children).filter(c=>c.nodeType===1).forEach(ch => ul.appendChild(buildItem(ch, visibleLangs)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
      });
    }
    return li;
  }

  // helpers for prefs
  function swapOrder(ws, delta){
    const entries = Object.values(prefs).sort((a,b)=>a.order-b.order);
    const idx = entries.findIndex(e => e.ws === ws);
    const target = idx + delta;
    if(target < 0 || target >= entries.length) return;
    // swap orders
    const a = entries[idx], b = entries[target];
    const t = a.order; a.order = b.order; b.order = t;
    saveLangPrefs(prefs); buildLangControls(); renderItems();
  }

  // finish init
  buildLangControls();
  renderItems();
  return container;
}

/* ===== Helper: collect AUni or return [] ===== */
function collectAUniMap(node){
  if(!node) return [];
  const a = Array.from(node.querySelectorAll('AUni'));
  if(a.length) return a.map(x=>({ws: x.getAttribute('ws') || '', text: x.textContent.trim()}));
  // fallback: Name with ws attribute directly or plain text (mono-lingual lists use ws on Name)
  if(node.hasAttribute && node.hasAttribute('ws')) return [{ws: node.getAttribute('ws') || '', text: (node.textContent||'').trim()}];
  const txt = (node.textContent||'').trim();
  return txt ? [{ws:'', text: txt}] : [];
}

/* ===== Build inline multilingual display honoring visibleLangs order ===== */
function buildMultilingualInlineHTML(names, abbrs, visibleLangs){
  // names: [{ws,text},...]; visibleLangs: ['en','id',...]
  if(!names || !names.length) return '(unnamed)';
  const shown = visibleLangs.map(ws => names.find(n => n.ws === ws)).filter(Boolean);
  if(!shown.length) return '(none)';
  const main = shown[0];
  const others = shown.slice(1);
  let html = `<span class="translation-main">${escapeHtml(main.text)}</span>`;
  if(others.length){
    html += ' ' + others.map(o => `<span class="translation-others">${escapeHtml(o.text)}</span>`).join(' · ');
  }
  // abbreviations for visible langs
  if(abbrs && abbrs.length){
    const abv = visibleLangs.map(ws => (abbrs.find(a => a.ws === ws) || {}).text).filter(Boolean);
    if(abv.length) html += ` <span class="small-muted">[${abv.map(escapeHtml).join(' / ')}]</span>`;
  }
  return html;
}

/* ===== Generic recursive fallback (unchanged) ===== */
function renderGenericView(root){
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Generic XML View'));
  const rootUL = create('ul', {cls:'tree'});
  rootUL.appendChild(build(root));
  container.appendChild(rootUL);
  return container;

  function build(node){
    const li = create('li');
    const childElements = Array.from(node.childNodes).filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.nodeValue.trim()));
    const hasChildren = childElements.length > 0;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '▾' : ' ');
    if(hasChildren) toggle.style.cursor='pointer';
    li.appendChild(toggle);

    const labelText = node.nodeType === 1 ? node.nodeName : '';
    const labelSpan = create('span');
    if(globalState.showNames && node.nodeType === 1) labelSpan.textContent = labelText + ': ';
    if(globalState.showNames && node.nodeType === 1) labelSpan.style.fontWeight = '600';
    li.appendChild(labelSpan);

    if(node.nodeType === 3){
      li.appendChild(document.createTextNode(node.nodeValue.trim()));
    } else {
      const textChild = Array.from(node.childNodes).filter(n=>n.nodeType===3 && n.nodeValue.trim())[0];
      if(textChild && childElements.every(n => n.nodeType === 3 || (n.nodeType === 1 && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3))){
        li.appendChild(create('span', {}, textChild.nodeValue.trim()));
      } else {
        const subUL = create('ul', {cls:'tree'});
        childElements.forEach(ch => subUL.appendChild(build(ch)));
        li.appendChild(subUL);
        if(hasChildren){
          toggle.addEventListener('click', ()=> {
            li.classList.toggle('collapsed');
            toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
          });
        }
      }
    }
    if(node.nodeType === 1) li.setAttribute('data-gen-label', node.nodeName);
    return li;
  }
}

/* ===== Phonology rendering (human-friendly) ===== */
function renderPhonologyView(xmlDoc){
  const root = xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Phonology Summary'));
  container.appendChild(create('div', {cls:'small-muted'}, `Version ${root.getAttribute('Version') || '—'} — DefaultVernWs: ${root.getAttribute('DefaultVernWs') || '—'}`));

  // index phonemes
  globalState.phonemeIndex = {};
  const phonemes = Array.from(xmlDoc.getElementsByTagName('PhPhoneme') || []);
  phonemes.forEach(p => {
    const id = p.getAttribute('Id');
    const symbol = pickAUni(p.querySelector(':scope > Name')) || '';
    const desc = p.querySelector(':scope > Description Run')?.textContent?.trim() || '';
    const codes = Array.from(p.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a => a.textContent.trim()).filter(Boolean);
    globalState.phonemeIndex[id] = { id, symbol, desc, codes, node: p };
  });

  // phoneme sets / inventory
  const sets = Array.from(xmlDoc.getElementsByTagName('PhPhonemeSet') || []);
  sets.forEach(set => {
    const setName = pickAUni(set.querySelector(':scope > Name')) || 'Phoneme Set';
    const setDiv = create('div', {cls:'natclass'});
    setDiv.appendChild(create('div', {cls:'section-title'}, setName));
    const setDesc = set.querySelector(':scope > Description Run')?.textContent;
    if(setDesc) setDiv.appendChild(create('div', {cls:'small-muted'}, setDesc));

    const table = create('table', {cls:'phonemes'});
    table.innerHTML = '<thead><tr><th>Symbol</th><th>Description</th><th>ID</th><th>Codes</th></tr></thead>';
    const tbody = create('tbody');
    const rows = Array.from(set.querySelectorAll(':scope > Phonemes PhPhoneme')) || phonemes;
    rows.forEach(pnode => {
      const pid = pnode.getAttribute('Id');
      const data = globalState.phonemeIndex[pid] || {
        id: pid,
        symbol: pickAUni(pnode.querySelector(':scope > Name')) || '',
        desc: pnode.querySelector(':scope > Description Run')?.textContent || '',
        codes: Array.from(pnode.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim())
      };
      const row = create('tr', {id: 'phoneme-row-' + data.id});
      const symbolCell = create('td');
      const symBtn = create('span', {cls:'symbol-pill'}, data.symbol || '(no symbol)');
      symBtn.style.cursor = 'pointer';
      symBtn.addEventListener('click', ()=> onPhonemeSymbolClick(data.id));
      symbolCell.appendChild(symBtn);
      row.appendChild(symbolCell);
      row.appendChild(create('td', {}, data.desc || ''));
      row.appendChild(create('td', {}, data.id));
      row.appendChild(create('td', {}, (data.codes && data.codes.join(', ')) || ''));
      tbody.appendChild(row);
      globalState.phonemeRowIds[data.id] = row.id;
    });
    table.appendChild(tbody);
    setDiv.appendChild(table);

    // boundary markers (if any)
    const bMarkers = Array.from(set.querySelectorAll(':scope > BoundaryMarkers PhBdryMarker')) || [];
    if(bMarkers.length){
      setDiv.appendChild(create('div', {cls:'section-title'}, 'Boundary Markers'));
      const bmList = create('div', {cls:'small-muted'});
      bMarkers.forEach(bm => {
        const bmName = pickAUni(bm.querySelector(':scope > Name')) || bm.getAttribute('Id') || '';
        const bmCodes = Array.from(bm.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim()).filter(Boolean);
        bmList.appendChild(create('div', {}, `${bmName} ${ bmCodes.length ? '(' + bmCodes.join(', ') + ')' : ''}`));
      });
      setDiv.appendChild(bmList);
    }

    container.appendChild(setDiv);
  });

  // natural classes
  const ncs = Array.from(xmlDoc.getElementsByTagName('PhNCSegments') || []);
  if(ncs.length){
    container.appendChild(create('div', {cls:'section-title'}, 'Natural Classes'));
    ncs.forEach((nc, idx) => {
      const ncId = nc.getAttribute('Id') || ('nc-' + idx);
      const name = pickAUni(nc.querySelector(':scope > Name')) || nc.getAttribute('Id') || 'Unnamed';
      const abbr = pickAUni(nc.querySelector(':scope > Abbreviation')) || '';
      const desc = nc.querySelector(':scope > Description Run')?.textContent || '';
      const ncEl = create('div', {cls:'natclass', id: 'natclass-' + ncId});
      const title = create('div', {cls:'section-title'}, name + (abbr ? (' (' + abbr + ')') : ''));
      ncEl.appendChild(title);
      if(desc) ncEl.appendChild(create('div', {cls:'small-muted'}, desc));
      const segments = Array.from(nc.querySelectorAll(':scope > Segments')).map(s => s.getAttribute('dst')).filter(Boolean);
      const membersDiv = create('div', {cls:'members'});
      segments.forEach(sid => {
        const phon = globalState.phonemeIndex[sid];
        const text = phon ? (phon.symbol || phon.id) : sid;
        const pill = create('span', {cls:'symbol-pill'}, text);
        pill.addEventListener('click', ()=> {
          if(globalState.phonemeRowIds[sid]) scrollToAndHighlight(globalState.phonemeRowIds[sid]);
          else alert('Phoneme ID ' + sid + ' not found in phoneme index.');
        });
        membersDiv.appendChild(pill);
        if(!globalState.idToNatclassIds[sid]) globalState.idToNatclassIds[sid] = [];
        globalState.idToNatclassIds[sid].push(ncEl.id);
      });
      ncEl.appendChild(membersDiv);
      container.appendChild(ncEl);
      globalState.natclassElements[ncEl.id] = ncEl;
    });
  }

  // simple placeholders for other sections (Environments, Contexts, Rules)
  const envs = Array.from(xmlDoc.getElementsByTagName('Environments') || []);
  envs.forEach(en => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Environments'));
    sec.appendChild(en.hasChildNodes() ? renderGenericView(en) : create('div', {cls:'small-muted'}, '(no environment definitions)'));
    container.appendChild(sec);
  });
  const ctxs = Array.from(xmlDoc.getElementsByTagName('Contexts') || []);
  ctxs.forEach(c => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Contexts'));
    sec.appendChild(c.hasChildNodes() ? renderGenericView(c) : create('div', {cls:'small-muted'}, '(no contexts defined)'));
    container.appendChild(sec);
  });

  // interactive behavior: click phoneme row -> highlight natclasses containing it
  Object.keys(globalState.phonemeRowIds).forEach(pid => {
    const rid = globalState.phonemeRowIds[pid];
    const row = document.getElementById(rid);
    if(row){
      row.addEventListener('click', ()=> {
        const natIds = globalState.idToNatclassIds[pid] || [];
        Object.values(globalState.natclassElements).forEach(el=> el.style.boxShadow = '');
        if(natIds.length){
          natIds.forEach(nid => {
            const el = globalState.natclassElements[nid];
            if(el){
              el.style.boxShadow = '0 0 0 3px rgba(11,110,219,0.08)';
              el.scrollIntoView({behavior:'smooth', block:'center'});
            }
          });
        } else {
          row.classList.add('highlight');
          setTimeout(()=> row.classList.remove('highlight'), 1200);
        }
      });
    }
  });

  return container;
}

/* ===== Utilities ===== */
function pickAUni(node){
  if(!node) return '';
  const aunis = Array.from(node.querySelectorAll('AUni'));
  if(aunis.length === 0) {
    const t = node.textContent && node.textContent.trim();
    return t || '';
  }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('fau')) return a.textContent.trim(); }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('en')) return a.textContent.trim(); }
  return aunis[0].textContent.trim();
}

function onPhonemeSymbolClick(phonId){
  const rowId = globalState.phonemeRowIds[phonId];
  if(!rowId){ alert('Phoneme entry not found: ' + phonId); return; }
  scrollToAndHighlight(rowId);
}
function scrollToAndHighlight(rowId){
  const el = document.getElementById(rowId);
  if(!el) return;
  document.querySelectorAll('tr.highlight').forEach(r=> r.classList.remove('highlight'));
  el.classList.add('highlight');
  el.scrollIntoView({behavior:'smooth', block:'center'});
  el.classList.add('scroll-target');
  setTimeout(()=> el.classList.remove('scroll-target'), 2200);
}

/* ===== Build standalone HTML for open/save (with escaped closing script tag) ===== */
function buildStandaloneHTML(){
  const render = byId('renderArea');
  const content = render.innerHTML;
  const doc = `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>FLEx XML View Export</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:18px;color:#111;background:#fbfbfb}
  .toggle{cursor:pointer;color:#0b6edb;margin-right:6px}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  .collapsed > ul{display:none}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .highlight{background: #fff2b8}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  .natclass{border:1px solid #e2e2e2;padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
</style>
</head>
<body>
${content}
<script>
  document.querySelectorAll('.toggle').forEach(t=> {
    const parent = t.parentElement;
    t.addEventListener('click', ()=> {
      parent.classList.toggle('collapsed');
      t.textContent = t.textContent === '▾' ? '▸' : '▾';
    });
  });
  document.querySelectorAll('.symbol-pill').forEach(p=> {
    p.addEventListener('click', ()=> {
      const txt = p.textContent.trim();
      const rows = document.querySelectorAll('table.phonemes tbody tr');
      for(const r of rows){
        if(r.cells[0] && r.cells[0].textContent.trim() === txt){
          r.scrollIntoView({behavior:'smooth', block:'center'});
          r.classList.add('highlight');
          setTimeout(()=> r.classList.remove('highlight'), 1800);
          return;
        }
      }
    });
  });
<\/script>
</body>
</html>`;
  return doc;
}

/* ===== localStorage helpers for prefs ===== */
function saveLangPrefs(obj){
  try{ localStorage.setItem(LANG_PREFS_KEY, JSON.stringify(obj)); } catch(e){}
}
function loadLangPrefs(){
  try{ const s = localStorage.getItem(LANG_PREFS_KEY); return s ? JSON.parse(s) : null; } catch(e){ return null; }
}
function saveLangPrefs(prefs){ try{ localStorage.setItem(LANG_PREFS_KEY, JSON.stringify(prefs)); } catch(e){} }

/* ===== End script ===== */
</script>
</body>
</html>