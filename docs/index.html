<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FLEx XML Viewer</title>
<style>
  :root{
    --accent:#0b6edb;
    --muted:#6c6c6c;
    --bg:#fbfbfb;
    --card:#fff;
      const converted = convertTextOrHtmlToHtml(postHtml, !!auto);
      content += `\n<div class=\"chart-epilogue\">${converted}</div>`;
  input[type=file]{padding:6px}
  button{background:var(--accent);color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#ddd;color:#111}
  .small-btn{padding:4px 8px;font-size:0.85rem;border-radius:6px}
  .viewer{margin-top:18px;background:var(--card);border:1px solid var(--border);padding:14px;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  /* Expand the white card to fit wide content so the browser handles scrollbars */
  .viewer{width:max-content;min-width:100%}
  /* Override XSL's table width:100% so it can define its natural width */
  .viewer .chartshell{width:max-content}
  /* Column resize UI for Text Chart tables */
  .chartshell th{position:relative}
  .col-resizer{position:absolute;top:0;right:0;width:8px;cursor:col-resize;user-select:none;height:100%}
  .col-resizer:after{content:"";position:absolute;top:0;bottom:0;left:2px;width:2px;background:transparent}
  .col-resizer.dragging:after{background:rgba(11,110,219,0.35)}
  /* Make content wrap when columns shrink (resizable mode switches table-layout to fixed) */
  .chartshell th, .chartshell td{overflow-wrap:anywhere; word-break:normal; min-width:0}
  /* Sticky (freeze) header rows for Text Chart */
  .chartshell.freeze-headers{ border-collapse: separate; border-spacing: 0; }
  /* Prefer row-level sticky for Firefox */
  .chartshell.freeze-headers thead tr.row.title1,
  .chartshell.freeze-headers thead tr.row.title2{
    position: sticky;
  }
  .chartshell.freeze-headers thead tr.row.title1 th,
  .chartshell.freeze-headers thead tr.row.title2 th{
    position: sticky;
    z-index: 3;
    background: #fff;
  }
  .chartshell.freeze-headers thead tr.row.title1{ top: var(--tc-sticky-top-1, 0px); }
  .chartshell.freeze-headers thead tr.row.title2{ top: var(--tc-sticky-top-2, 32px); }
  .chartshell.freeze-headers thead tr.row.title1 th{ top: var(--tc-sticky-top-1, 0px); }
  .chartshell.freeze-headers thead tr.row.title2 th{ top: var(--tc-sticky-top-2, 32px); }
  /* Ensure borders render above body cells */
  .chartshell.freeze-headers thead tr.row.title1{ z-index: 5; }
  .chartshell.freeze-headers thead tr.row.title2{ z-index: 6; }
  .chartshell.freeze-headers thead tr.row.title2 th{ z-index: 7; }
  .chartshell-wrapper{ position: relative; }
  .chartshell-sticky-spacer{ height: var(--tc-sticky-spacer, 0px); }
  /* Interlinear pair layout is defined by XSL-injected <style>; avoid overriding here. */
  .controls-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .prologue-panel{display:none;margin-top:10px;background:#f7fbff;border:1px solid #d9ebff;padding:10px 12px;border-radius:8px}
  .prologue-grid{display:grid;grid-template-columns:140px 1fr;gap:8px 10px;align-items:center}
  .prologue-grid .full{grid-column:1 / -1}
  .prologue-grid input[type=text]{width:100%;padding:6px;border:1px solid var(--border);border-radius:6px}
  .prologue-grid select{padding:6px;border:1px solid var(--border);border-radius:6px}
  .prologue-grid textarea{width:100%;min-height:80px}
  .section-title{font-weight:600;margin:8px 0;font-size:1rem}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  ul.tree li{margin:4px 0;position:relative;padding-left:6px}
  .toggle{user-select:none;cursor:pointer;margin-right:6px;color:var(--accent)}
  .collapsed > ul{display:none}
  .label{font-weight:600;margin-right:6px}
  .muted{color:var(--muted);font-size:0.95rem}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  tr.highlight{background:var(--highlight) !important}
  .natclass{border:1px solid var(--border);padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
  .natclass .members{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .symbol-pill:hover{background:#e8f2ff}
  .small-muted{font-size:0.9rem;color:var(--muted)}
  .translation-main{font-weight:600}
  .translation-others{color:var(--muted);margin-left:6px;font-size:0.95rem}
  .lang-controls{display:flex;align-items:center;gap:8px;margin:6px 0 12px 0;flex-wrap:wrap}
  .lang-controls .lang-item{display:flex;align-items:center;gap:6px;padding:4px}
  .icon-btn{background:#fff;border:1px solid #e0e0e0;padding:5px 7px;border-radius:6px;cursor:pointer}
  .wordform-card{border:1px solid #e6e6e6;padding:10px;border-radius:8px;margin-bottom:8px;background:linear-gradient(#fff,#fcfcff)}
  .wordform-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .wordform-main{font-weight:700;font-size:1.05rem}
  .wordform-meta{color:var(--muted);font-size:0.9rem}
  .wordform-body{margin-top:8px}
  /* Abbreviations UI and rendered block */
  .abbrev-panel{display:none;margin-top:10px;background:#fff8f0;border:1px solid #ffe2bf;padding:10px 12px;border-radius:8px}
  .abbrev-grid{display:grid;grid-template-columns:160px 1fr;gap:8px 10px;align-items:center}
  .abbrev-grid input[type=text]{width:100%;padding:6px;border:1px solid var(--border);border-radius:6px}
  .abbrev-grid .rows{grid-column:1 / -1}
  .abbr-row{display:grid;grid-template-columns:auto 1fr 2fr;gap:8px;margin-bottom:6px;align-items:center}
  .abbr-row input{min-width:0}
  .abbr-abbr{font-family:monospace;padding:4px 6px;border:1px solid #e5e5e5;border-radius:6px;background:#f7f7f7;white-space:nowrap}
  .chart-abbrev-block{border:1px solid #eee;padding:8px 10px;border-radius:6px;background:linear-gradient(#fff,#fcfcf8);margin:10px 0}
  .chart-abbrev-block h3{margin:0 0 6px 0;font-size:1rem}
  .chart-abbrev-block ul{margin:0;padding-left:18px}
  .chart-abbrev-block li{margin:3px 0}
  /* ListRef controls panel */
  .listref-panel{display:none;margin-top:10px;background:#f4fff4;border:1px solid #cfe9cf;padding:10px 12px;border-radius:8px}
  .listref-grid{display:grid;grid-template-columns:160px 1fr;gap:8px 10px;align-items:center}
  .listref-grid .rows{grid-column:1 / -1}
  .lr-row{display:grid;grid-template-columns:auto auto auto 1fr;gap:8px;margin-bottom:6px;align-items:center}
  .lr-row .lr-abbr{font-family:monospace;padding:4px 6px;border:1px solid #e5e5e5;border-radius:6px;background:#f7f7f7;white-space:nowrap}
  .lr-row .lr-abbr.is-hidden{color:#9a9a9a;text-decoration:line-through}
  .lr-row .lr-chip{background:#eef8ee;border:1px solid #dcefdc;padding:2px 6px;border-radius:999px;font-size:0.85rem}
  .lr-row button{min-width:28px}
  /* Collapsible panels */
  .collapsible-header{display:flex;align-items:center;gap:8px;cursor:pointer;user-select:none;font-weight:600;margin:2px 0}
  .collapsible-header .chev{margin-left:auto;color:var(--muted)}
  .collapsible-body{margin-top:8px}
  #prologuePanel[data-collapsed="1"] .collapsible-body,
  #abbrevPanel[data-collapsed="1"] .collapsible-body,
  #appendHtmlPanel[data-collapsed="1"] .collapsible-body,
  #listRefPanel[data-collapsed="1"] .collapsible-body,
  #postloguePanel[data-collapsed="1"] .collapsible-body{display:none}
  /* Grouping UI */
  .lr-group{border:1px solid #dcefdc;background:#f8fff8;border-radius:6px;padding:8px;margin-bottom:8px}
  .lr-group-header{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:6px}
  .lr-group-items{margin-left:24px}
  /* Inserted external HTML blocks */
  .inserted-html-before-prologue, .inserted-html-after-chart{border:1px solid #eee;padding:8px 10px;border-radius:6px;background:#fff; margin:10px 0}
  .table-view{width:100%;border-collapse:collapse}
  .table-view th,.table-view td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  .controls-inline{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  footer{margin-top:28px;padding-top:10px;border-top:1px solid #e6e6e6;color:var(--muted);font-size:0.9rem}
  /* Print-friendly adjustments */
@media print {
  /* Page margins */
  @page {
    margin: 12mm;
  }

  /* High-contrast and color handling */
  html, body {
    background: #fff !important;
    color: #000 !important;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }

  /* Slightly tighter text to fit more per page */
  :root {
    --font-size: 12px;            /* was 14px */
    --cell-border: 1px solid #000;
    --header-border-thick: 2px solid #000;
    --row-end-border: 1px solid #000;
    --para-end-border: 2px solid #000;
  }

  /* Hide interactive chrome in print */
  header, footer, .controls-row,
  #openBtn, #saveBtn, #resetBtn, #transformBtn,
  #fileInput, #xmlInput, .small-muted.controls,
  .lang-controls, .controls-inline, .viewer .small-muted {
    display: none !important;
  }

  /* Flatten the viewer card */
  .viewer {
    width: auto !important;       /* let it use full page width */
    min-width: 0 !important;
    box-shadow: none !important;
    border: none !important;
    padding: 0 !important;
    background: transparent !important;
  }

  /* Table layout for print (chart only) */
  .chartshell {
    width: 100% !important;       /* fit page width */
    border-collapse: collapse !important;
    border-spacing: 0 !important;
  }

  /* Remove colored headers; rely on thicker borders */
  .row.title1 th,
  .row.title2 th {
    background: transparent !important;
  }

  /* Solid borders for cells and group rails (chart only) */
  .chartshell th, .chartshell td {
    border: 1px solid #000 !important;
    padding: 6px 6px !important; /* a bit tighter for paper */
  }
  .chartshell th.group-end, .chartshell td.group-end {
    border-right: 2px solid #000 !important;
  }
  /* Preserve thicker sentence/paragraph end borders in print */
  .chartshell tr.endSent > th, .chartshell tr.endSent > td {
    border-bottom: var(--row-end-border) !important;
  }
  .chartshell tr.endPara > th, .chartshell tr.endPara > td {
    border-bottom: var(--para-end-border) !important;
  }
  .chartshell tr > .group-start:first-child {
    border-left: 2px solid #000 !important;
  }

  /* Keep rows together if possible (browser support varies) */
  .chartshell tr {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Interlinear: keep gloss readable in grayscale */
  .chartshell .interlinear .g {
    color: #333 !important;
  }

  /* Optional: show link targets in print */
  a[href]:after {
    content: " (" attr(href) ")";
    font-size: 0.9em;
  }
  /* Don't print column resize handles */
  .col-resizer { display: none !important; }
  /* Keep abbreviations list together if possible */
  .chart-abbrev-block { break-inside: avoid; page-break-inside: avoid; }
  /* Page breaks for inserted blocks */
  .inserted-html-before-prologue { break-after: page; page-break-after: always; }
  .inserted-html-after-chart { break-before: page; page-break-before: always; }
}
</style>
</head>
<body>

<header>
  <h1>FLEx XML Viewer</h1>
  <div style="margin-left:auto" class="small-muted">© 2025 Seth Johnston</div>
</header>

  <section style="background:#eef5ff;border:1px solid #c8dbff;padding:10px 14px;border-radius:8px;margin-bottom:12px">
  <h2 style="font-size:1rem;margin-top:0">About FLEx XML Viewer</h2>
  <p>
    <strong>FLEx XML Viewer</strong> is a client-side web app for viewing and exploring
    <a href="https://software.sil.org/fieldworks/" target="_blank" rel="noopener noreferrer">FieldWorks (FLEx)</a>
    XML exports in a structured, readable format. This app is a part of the <a href="https://github.com/rulingAnts/flet" target="_blank" rel="noopener noreferrer">Field Linguistics Extension Tools collection</a>.
  </p>
  <p style="margin-top:6px"><strong>Privacy</strong>: All conversions happen locally in your browser — your XML and language data never leave your device. There are no uploads or analytics. Preferences (like language order or view options) are stored only in your browser’s local storage. Using “Open in new window” or “Save as HTML” creates a local snapshot you can choose to save or share.</p>
  <p>This viewer supports the following FieldWorks XML export types:</p>
  <ul style="margin-top:4px">
    <li><strong>Discourse Charts</strong> — displays FLEx Text Charts (Discourse Charts) as HTML tables with resizable columns (click and drag column borders in second header row), preserving formatting and interlinear structure.</li>
    <li><strong>Lists</strong> — displays hierarchical <code>&lt;list&gt;</code> structures as collapsible nested lists.</li>
    <li><strong>Translated Lists</strong> — handles multilingual <code>&lt;AUni&gt;</code>-based lists with language ordering and visibility controls.</li>
    <li><strong>Phonology</strong> — renders natural classes, phoneme inventories, and cross-references in human-readable tables.</li>
    <li><strong>Wordforms</strong> — displays lexical items and analyses in expandable cards or sortable tables.</li>
    <li><strong>Generic XML</strong> — provides a recursive tree view for any other well-formed XML data.</li>
  </ul>
  <p>
    This app does <em>not</em> process <strong>LIFT</strong> or <strong>FLExText</strong> exports — those should be opened directly in FLEx. XLingPaper XML exports can open with XLingPpaer. And Word XML files should be opened in Microsoft Word.
  </p>
</section>

<textarea id="xmlInput" placeholder="Paste XML here or choose a file..." hidden></textarea>

<div class="controls-row">
  <button id="transformBtn">Transform</button>
  <button id="resetBtn" class="secondary">Reset</button>

  <label style="display:flex;align-items:center;gap:8px" class="small-muted">
    <input id="showNames" type="checkbox"> Show element names
  </label>

  <label id="repeatHeadersContainer" style="display:none;align-items:center;gap:8px" class="small-muted" title="When printing a Text Chart, repeat the top two header rows at the top of each page">
    <input id="repeatHeaders" type="checkbox"> Repeat chart headers on each printed page
  </label>

  <label id="freezeHeadersContainer" style="display:none;align-items:center;gap:8px" class="small-muted" title="Keep the two chart header rows visible while scrolling">
    <input id="freezeHeaders" type="checkbox"> Freeze chart headers when scrolling
  </label>

  <div style="margin-left:auto;display:flex;gap:8px;align-items:left">
    <input id="fileInput" type="file" accept=".xml,.xml.txt" />
    <button id="printBtn" class="secondary">Print / Export to PDF</button>
    <button id="openBtn" class="secondary" style="display:none">Open in new window</button>
    <button id="saveBtn" class="secondary">Save as HTML</button>
  </div>
</div>

<!-- Optional heading and preface (HTML) to insert before a Text Chart -->
<div id="prologuePanel" class="prologue-panel" aria-live="polite" data-collapsed="1">
  <div class="collapsible-header" id="prologueHeader">
    <span class="small-muted">Chart header and note (optional)</span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="prologue-grid">
    <label for="titleTag">Title element</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="titleTag" aria-label="Title element">
        <option value="h1">h1</option>
        <option value="h2">h2</option>
        <option value="h3">h3</option>
        <option value="div">div</option>
        <option value="p">p</option>
      </select>
      <input id="titleText" type="text" placeholder="Enter a chart title (optional)" />
      <button id="clearTitleBtn" class="small-btn secondary" title="Clear title">Clear</button>
    </div>

    <label for="prefaceHtml">Preface (HTML allowed)</label>
    <div class="full">
      <textarea id="prefaceHtml" placeholder="Type any HTML to appear before the chart (optional)"></textarea>
      <div class="small-muted" style="margin-top:6px">
        Tip: You can include basic HTML like <code>&lt;p&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;em&gt;</code>, or links. 
        If you don't know HTML, leave that to us — when “Auto-convert line breaks” is on, Enter makes a new paragraph and Shift+Enter inserts a line break.
      </div>
      <label class="small-muted" style="display:flex;align-items:center;gap:8px;margin-top:6px">
        <input id="prefaceAuto" type="checkbox" checked> Auto-convert line breaks (Enter = new paragraph, Shift+Enter = line break)
      </label>
    </div>
    <div></div>
    <div style="display:flex;gap:8px">
      <button id="clearPrefaceBtn" class="small-btn secondary" title="Clear preface">Clear preface</button>
    </div>
  </div>
  </div>
</div>

<!-- Abbreviations list (labels + optional definitions) -->
<div id="abbrevPanel" class="abbrev-panel" aria-live="polite" data-collapsed="1">
  <div class="collapsible-header" id="abbrevHeader">
    <span class="small-muted">Abbreviations List (optional)</span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="abbrev-grid">
    <label for="abbrevInclude">Include list</label>
    <label style="display:flex;align-items:center;gap:8px">
      <input id="abbrevInclude" type="checkbox" checked> Include abbreviations in output
    </label>

    <label for="abbrevPosition">Position</label>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="abbrevPosition">
        <option value="top">Top (below title/preface)</option>
        <option value="bottom">Bottom (after chart)</option>
      </select>
      <button id="abbrevResetFromChart" class="small-btn secondary" title="Re-scan listRef items from chart">Reset from chart</button>
    </div>

    <div class="rows">
  <div class="small-muted" style="margin:6px 0">Each abbreviation is fixed from the chart. Edit a Name and optional Description:</div>
      <div id="abbrevRows"></div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <button id="abbrevAddManual" class="small-btn" title="Add a custom abbreviation">Add abbreviation</button>
        <span class="small-muted">Manual abbreviations are saved and exported with the chart.</span>
      </div>
      <div id="abbrevEmptyMsg" class="small-muted" style="display:none">No listRef items found in this chart.</div>
    </div>
  </div>
  </div>
</div>

<!-- Additional HTML (before Prologue and after Text Chart) -->
<div id="appendHtmlPanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
  <div class="collapsible-header" id="appendHeader">
    <span class="small-muted">Additional HTML Document (optional) - <i>i.e. include your interlinear text with free translations (or include some other description or write-up to bundle with your chart).</i></span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="prologue-grid">
    <label for="beforeHtmlInput">Before Prologue</label>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <input id="beforeHtmlInput" type="file" accept=".html,.htm,text/html" />
      <button id="clearBeforeHtmlBtn" class="small-btn secondary">Clear</button>
      <span id="beforeHtmlStatus" class="small-muted"></span>
    </div>
    <label for="afterHtmlInput">After Text Chart</label>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <input id="afterHtmlInput" type="file" accept=".html,.htm,text/html" />
      <button id="clearAfterHtmlBtn" class="small-btn secondary">Clear</button>
      <span id="afterHtmlStatus" class="small-muted"></span>
    </div>
    <div class="full small-muted" style="margin-top:6px">
      Tip: The “After Text Chart” HTML will appear before Abbreviations when Abbreviations are placed at the end.
    </div>
  </div>
  <div class="small-muted" style="margin-top:6px">Print: Page breaks are inserted after the Before-Prologue HTML and before the After-Chart HTML.</div>
  </div>
  </div>

  <!-- Epilogue (HTML/Text after everything in export) -->
  <div id="postloguePanel" class="prologue-panel" aria-live="polite" style="display:none" data-collapsed="1">
    <div class="collapsible-header" id="postlogueHeader">
      <span class="small-muted">Epilogue (optional) — text or HTML to append at the very end</span>
      <span class="chev">▸</span>
    </div>
    <div class="collapsible-body">
      <div class="prologue-grid">
        <label for="postlogueHtml">Epilogue</label>
        <div class="full">
          <textarea id="postlogueHtml" placeholder="Type text or HTML to appear at the very end (optional)"></textarea>
          <label class="small-muted" style="display:flex;align-items:center;gap:8px;margin-top:6px">
            <input id="postlogueAuto" type="checkbox" checked> Auto-convert line breaks (Enter = new paragraph, Shift+Enter = line break)
          </label>
        </div>
      </div>
    </div>
    </div>

  <!-- ListRef Styling/Ordering -->
<div id="listRefPanel" class="listref-panel" aria-live="polite" style="display:none" data-collapsed="1">
  <div class="collapsible-header" id="listRefHeader">
    <span class="small-muted">Text Chart Marker Display and Order Settings</span>
    <span class="chev">▸</span>
  </div>
  <div class="collapsible-body">
  <div class="listref-grid">
    <div class="rows">
      <div class="small-muted" style="margin:6px 0; display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap">
        <span>Control how specific TextChart Markers render in cells. Order here sets left-to-right order within the same cell. Styling and visibility only affect in-cell TextChart Markers; the Abbreviations list remains alphabetical.</span>
        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap">
          <label title="Choose how to order tokens in cells">
            <select id="listRefEnforceMode">
              <option value="none" selected>No ordering (source order)</option>
              <option value="groups">Enforce within groups</option>
              <option value="global">Enforce globally</option>
            </select>
          </label>
          <button id="listRefToggleOrder" class="small-btn secondary" title="Toggle ordering direction">(top → bottom)</button>
          <button id="listRefShowAll" class="small-btn" title="Show all abbreviations">Show all</button>
          <button id="listRefHideAll" class="small-btn secondary" title="Hide all abbreviations">Hide all</button>
          <button id="listRefResetAllStyles" class="small-btn secondary" title="Clear styles for all groups and items (keep visibility/order)">Reset all styles</button>
          <button id="listRefResetOrder" class="small-btn secondary" title="Reset order to most prevalent pattern from this chart">Reset order</button>
        </div>
      </div>
      <div id="listRefGroups"></div>
      <div id="listRefRows"></div>
      <div id="listRefWarnings" class="small-muted" style="margin-top:8px; display:none"></div>
      <div style="margin-top:8px">
        <div class="small-muted" style="font-weight:600;margin-bottom:6px">Groups</div>
        <div id="listRefGroupList"></div>
        <div style="margin-top:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <input id="listRefNewGroupName" type="text" placeholder="New group name" style="padding:6px;border:1px solid #e5e5e5;border-radius:6px">
          <button id="listRefAddGroup" class="small-btn">Add group</button>
        </div>
      </div>
    </div>
  </div>
  </div>
</div>

<div id="viewer" class="viewer" aria-live="polite">
  <div id="renderArea" class="small-muted">Paste or upload an XML file, then click Transform.</div>
</div>

<footer>
  <div>© 2025 Seth Johnston. This software is licensed under the <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" rel="noopener noreferrer">GNU Affero General Public License v3.0 (AGPL-3.0)</a>.</div>
  <div>The vast majority of this code was generated collaboratively with <strong>ChatGPT (GPT-5)</strong> by OpenAI, under the author’s direction and guidance.</div>
  <div>Download the latest Windows Installer from the GitHub Project page <a href="https://github.com/rulingAnts/flexml_display/" target="_blank" rel="noopener noreferrer">here</a>.</div>
</footer>

<script>
/* ===== Helpers ===== */
const byId = id => document.getElementById(id);
const escapeHtml = s => String(s||'').replace(/[&<>"]/g, c=>'&' + ({'&':'amp','<':'lt','>':'gt','"':'quot'})[c] + ';');
function create(tag, attrs={}, text){
  const el = document.createElement(tag);
  for(const k in attrs){
    if(k==='cls') el.className = attrs[k];
    else el.setAttribute(k, attrs[k]);
  }
  if(text !== undefined && text !== null) el.textContent = text;
  return el;
}

/* ===== Persistence keys and state ===== */
const LANG_PREFS_KEY = 'flex_xml_viewer_lang_prefs_v1';
const WORDFORM_PREFS_KEY = 'flex_xml_viewer_wordform_prefs_v1';
const TEXTCHART_PROLOGUE_KEY = 'flex_textchart_prologue_v1';
const TEXTCHART_POSTLOGUE_KEY = 'flex_textchart_postlogue_v1';
const PRINT_HEADERS_KEY = 'flex_textchart_repeat_headers_v1';
const FREEZE_HEADERS_KEY = 'flex_textchart_freeze_headers_v1';
const ABBREV_PREFS_KEY = 'flex_textchart_abbrevs_v1';
const LISTREF_PREFS_KEY = 'flex_textchart_listrefs_v2';

let globalState = {
  phonemeIndex: {},
  idToNatclassIds: {},
  natclassElements: {},
  phonemeRowIds: {},
  showNames: false,
  chartAbbrevLabels: [],
  listRefLabels: [],
  listRefPrefs: null,
  abbrevPrefs: null,
  beforeHtml: null,
  beforeHtmlName: '',
  afterHtml: null,
  afterHtmlName: '',
  postlogueHtml: '',
  postlogueAuto: true
};

function saveJSON(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); } catch(e){} }
function loadJSON(key){ try{ const s = localStorage.getItem(key); return s ? JSON.parse(s) : null; } catch(e){ return null; } }

/* ===== File & UI wiring ===== */
byId('fileInput').addEventListener('change', async e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  byId('xmlInput').value = text;
});

byId('resetBtn').addEventListener('click', ()=>{
  byId('xmlInput').value = '';
  byId('renderArea').innerHTML = '<div class="small-muted">Paste or upload an XML file, then click Transform.</div>';
  // Hide optional chart prologue controls when no chart is displayed
  showProloguePanel(false);
});

byId('transformBtn').addEventListener('click', async ()=> {
  const xmlText = byId('xmlInput').value.trim();
  if(!xmlText){ alert('Please paste or upload an XML document first.'); return; }
  try {
    const p = new DOMParser();
    const xmlDoc = p.parseFromString(xmlText, 'application/xml');
    if(xmlDoc.querySelector('parsererror')) throw new Error('XML parse error');
    await renderDocument(xmlDoc);
  } catch(err){
    alert('Error parsing XML: ' + err.message);
  }
});

byId('openBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML();
  const w = window.open('', '_blank');
  w.document.write(html);
  w.document.close();
});

// Print / Export to PDF
byId('printBtn').addEventListener('click', ()=>{
  // Build a standalone snapshot and print from a new window so content/styles are captured
  const html = buildStandaloneHTML();
  const w = window.open('', '_blank');
  if(!w) return;
  w.document.write(html);
  w.document.close();
  const tryPrint = () => { try { w.focus(); w.print(); } catch(_) {} };
  if(w.document.readyState === 'complete') setTimeout(tryPrint, 60);
  else w.addEventListener('load', () => setTimeout(tryPrint, 60));
});

function sanitizeFilename(name){
  // Remove illegal characters for Windows/macOS, collapse spaces, and trim
  return (name || 'export')
    .replace(/[\\/:*?"<>|]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 120);
}
function getExportTitleFromPrologue(){
  let exportTitle = 'FLEx XML View Export';
  const render = byId('renderArea');
  if(!render) return exportTitle;
  const prologueNode = render.querySelector(':scope > .chart-prologue');
  if (prologueNode) {
    const h1 = prologueNode.querySelector('h1');
    const anyHead = prologueNode.querySelector('h1,h2,h3,h4,h5,h6,div,p');
    const titleNode = h1 || anyHead;
    if (titleNode && titleNode.textContent) {
      const t = titleNode.textContent.replace(/\s+/g, ' ').trim();
      if (t) exportTitle = t;
    }
  }
  return exportTitle;
}
function suggestExportFilename(){
  const baseTitle = getExportTitleFromPrologue();
  const hasChart = !!byId('renderArea')?.querySelector('table.chartshell');
  const withContext = hasChart ? `${baseTitle} — Text Chart` : baseTitle;
  let name = sanitizeFilename(withContext || 'FLEx XML View Export');
  if(!/\.html?$/i.test(name)) name += '.html';
  return name;
}
byId('saveBtn').addEventListener('click', async ()=>{
  const html = buildStandaloneHTML();
  const filename = suggestExportFilename();
  // Use File System Access API if available (Chrome/Edge/Electron Chromium)
  if(window.showSaveFilePicker){
    try{
      const handle = await window.showSaveFilePicker({
        suggestedName: filename,
        types: [{ description: 'HTML Document', accept: { 'text/html': ['.html', '.htm'] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(new Blob([html], {type:'text/html'}));
      await writable.close();
      return;
    } catch(err){
      if(err && err.name === 'AbortError') return; // user canceled
      console.warn('showSaveFilePicker failed, falling back to download:', err);
      // fall through to anchor download
    }
  }
  // Fallback: classic download
  const blob = new Blob([html], {type:'text/html'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
});

byId('showNames').addEventListener('change', e=>{
  globalState.showNames = e.target.checked;
  document.querySelectorAll('[data-gen-label]').forEach(el=>{
    const label = el.getAttribute('data-gen-label');
    const prev = el.previousSibling;
    if(prev) prev.textContent = globalState.showNames ? (label + ': ') : '';
  });
});

/* ===== Print header repetition (Text Chart only) ===== */
function setPrintHeadersEnabled(enabled){
  const STYLE_ID = 'textchart-print-headers-style';
  let el = document.getElementById(STYLE_ID);
  if(enabled){
    // With thead emitted by XSL, most browsers repeat header automatically. Add guard CSS for reliability.
    const css = `@media print {\n  thead { display: table-header-group !important; }\n}`;
    if(!el){ el = document.createElement('style'); el.id = STYLE_ID; document.head.appendChild(el); }
    el.textContent = css;
  } else {
    if(el) el.remove();
  }
}
function initRepeatHeadersControl(){
  const box = byId('repeatHeaders');
  const container = byId('repeatHeadersContainer');
  if(!box || !container) return;
  const saved = loadJSON(PRINT_HEADERS_KEY);
  const enabled = !!(saved && saved.enabled);
  box.checked = enabled;
  setPrintHeadersEnabled(enabled);
  box.addEventListener('change', ()=>{
    const val = !!box.checked;
    setPrintHeadersEnabled(val);
    saveJSON(PRINT_HEADERS_KEY, { enabled: val });
  });
}
// Initialize once
initRepeatHeadersControl();

/* ===== Freeze headers (sticky title rows) ===== */
function setFreezeHeadersEnabled(enabled){
  const area = byId('renderArea');
  const tbl = area?.querySelector('table.chartshell');
  if(!tbl) return;
  const wrapper = tbl.closest('.chartshell-wrapper') || tbl.parentElement;
  if(enabled){
    tbl.classList.add('freeze-headers');
    // Ensure we have a spacer element right before the table to offset layout when headers stick
    let spacer = wrapper?.querySelector(':scope > .chartshell-sticky-spacer');
    if(!spacer){
      spacer = document.createElement('div');
      spacer.className = 'chartshell-sticky-spacer';
      if(wrapper) wrapper.insertBefore(spacer, tbl);
      else tbl.parentElement?.insertBefore(spacer, tbl);
    }
    computeStickyOffsets();
  } else {
    tbl.classList.remove('freeze-headers');
    const spacer = wrapper?.querySelector(':scope > .chartshell-sticky-spacer');
    if(spacer) spacer.remove();
    document.documentElement.style.removeProperty('--tc-sticky-top-1');
    document.documentElement.style.removeProperty('--tc-sticky-top-2');
    document.documentElement.style.removeProperty('--tc-sticky-spacer');
  }
}
function computeStickyOffsets(){
  const area = byId('renderArea');
  const tbl = area?.querySelector('table.chartshell');
  if(!tbl) return;
  const head = tbl.querySelector('thead');
  const r1 = head?.querySelector('tr.row.title1');
  const r2 = head?.querySelector('tr.row.title2');
  const rect1 = r1?.getBoundingClientRect();
  const rect2 = r2?.getBoundingClientRect();
  // Account for any fixed UI at the top (none by default). We can also consider header height.
  const topBase = 0;
  const h1 = rect1 ? Math.ceil(rect1.height) : 0;
  const h2 = rect2 ? Math.ceil(rect2.height) : 0;
  document.documentElement.style.setProperty('--tc-sticky-top-1', topBase + 'px');
  document.documentElement.style.setProperty('--tc-sticky-top-2', (topBase + h1) + 'px');
  document.documentElement.style.setProperty('--tc-sticky-spacer', (h1 + h2) + 'px');
}
function initFreezeHeadersControl(){
  const box = byId('freezeHeaders');
  const container = byId('freezeHeadersContainer');
  if(!box || !container) return;
  const saved = loadJSON(FREEZE_HEADERS_KEY);
  const enabled = !!(saved && saved.enabled);
  box.checked = enabled;
  // Only apply after a chart is rendered; this function may run before the table exists
  box.addEventListener('change', ()=>{
    const val = !!box.checked; saveJSON(FREEZE_HEADERS_KEY, { enabled: val }); setFreezeHeadersEnabled(val);
  });
}

/* ===== Collapsible panels (Text Chart settings) ===== */
const COLLAPSE_STATE_KEY = 'flex_textchart_collapse_state_v1';
function loadCollapseState(){ return loadJSON(COLLAPSE_STATE_KEY) || {}; }
function saveCollapseState(s){ saveJSON(COLLAPSE_STATE_KEY, s); }
function wireCollapsible(panelId, headerId){
  const panel = byId(panelId); const header = byId(headerId);
  if(!panel || !header) return;
  let state = loadCollapseState();
  const key = panelId;
  const collapsed = state[key] !== undefined ? !!state[key] : true;
  panel.setAttribute('data-collapsed', collapsed ? '1' : '0');
  const chev = header.querySelector('.chev'); if(chev) chev.textContent = collapsed ? '▸' : '▾';
  header.setAttribute('role','button'); header.setAttribute('tabindex','0'); header.setAttribute('aria-expanded', (!collapsed).toString());
  function toggle(){
    const isCollapsed = panel.getAttribute('data-collapsed') === '1';
    panel.setAttribute('data-collapsed', isCollapsed ? '0' : '1');
    if(chev) chev.textContent = isCollapsed ? '▾' : '▸';
    header.setAttribute('aria-expanded', isCollapsed ? 'true' : 'false');
    state = loadCollapseState(); state[key] = !isCollapsed; saveCollapseState(state);
  }
  header.addEventListener('click', toggle);
  header.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); toggle(); } });
}

/* ===== Prologue (title + preface HTML) controls wiring ===== */
function loadProloguePrefs(){
  const d = loadJSON(TEXTCHART_PROLOGUE_KEY) || {};
  return {
    tag: d.tag || 'h1',
    titleText: d.titleText || '',
    prefaceHtml: d.prefaceHtml || '', // stores raw user text or HTML
    autoConvert: typeof d.autoConvert === 'boolean' ? d.autoConvert : true
  };
}
function saveProloguePrefs(p){ saveJSON(TEXTCHART_PROLOGUE_KEY, p); }
function initPrologueControls(){
  const panel = byId('prologuePanel');
  const tagSel = byId('titleTag');
  const titleIn = byId('titleText');
  const preTA = byId('prefaceHtml');
  const preAuto = byId('prefaceAuto');
  const clearTitleBtn = byId('clearTitleBtn');
  const clearPrefaceBtn = byId('clearPrefaceBtn');
  if(!panel || !tagSel || !titleIn || !preTA) return;
  const prefs = loadProloguePrefs();
  tagSel.value = prefs.tag || 'h1';
  titleIn.value = prefs.titleText || '';
  preTA.value = prefs.prefaceHtml || '';
  if(preAuto) preAuto.checked = !!prefs.autoConvert;
  const onChange = ()=>{
    const p = { tag: tagSel.value, titleText: titleIn.value, prefaceHtml: preTA.value, autoConvert: !!(preAuto && preAuto.checked) };
    saveProloguePrefs(p);
    // Live-update DOM if a text chart is displayed
    applyPrologueToRenderArea(p);
  };
  tagSel.addEventListener('change', onChange);
  titleIn.addEventListener('input', onChange);
  preTA.addEventListener('input', onChange);
  preAuto?.addEventListener('change', onChange);
  clearTitleBtn?.addEventListener('click', ()=>{ titleIn.value=''; onChange(); });
  clearPrefaceBtn?.addEventListener('click', ()=>{ preTA.value=''; onChange(); });

  // Map Enter to paragraph and Shift+Enter to single line break within the textarea
  preTA.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      e.preventDefault();
      const isShift = e.shiftKey;
      const val = preTA.value;
      const start = preTA.selectionStart;
      const end = preTA.selectionEnd;
      const insertText = isShift ? '\n' : '\n\n';
      preTA.value = val.slice(0, start) + insertText + val.slice(end);
      const newPos = start + insertText.length;
      preTA.selectionStart = preTA.selectionEnd = newPos;
      onChange();
    }
  });
}
// Ensure controls are initialized on load
initPrologueControls();
function showProloguePanel(show){ byId('prologuePanel').style.display = show ? 'block' : 'none'; }

/* ===== Postlogue controls (stored and used only for export) ===== */
function loadPostloguePrefs(){
  const d = loadJSON(TEXTCHART_POSTLOGUE_KEY) || {};
  return {
    html: d.html || '',
    autoConvert: typeof d.autoConvert === 'boolean' ? d.autoConvert : true
  };
}
function savePostloguePrefs(p){ saveJSON(TEXTCHART_POSTLOGUE_KEY, p); }
function initPostlogueControls(){
  const panel = byId('postloguePanel'); if(!panel) return;
  const ta = byId('postlogueHtml');
  const auto = byId('postlogueAuto');
  const prefs = loadPostloguePrefs();
  if(ta) ta.value = prefs.html || '';
  if(auto) auto.checked = !!prefs.autoConvert;
  const onChange = ()=>{
    const p = { html: ta?.value || '', autoConvert: !!(auto && auto.checked) };
    savePostloguePrefs(p);
    globalState.postlogueHtml = p.html; globalState.postlogueAuto = p.autoConvert;
    applyEpilogueToRenderArea(p);
  };
  ta?.addEventListener('input', onChange);
  auto?.addEventListener('change', onChange);
  // keyboard conveniences similar to prologue
  ta?.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      e.preventDefault();
      const isShift = e.shiftKey; const val = ta.value; const start = ta.selectionStart; const end = ta.selectionEnd;
      const insertText = isShift ? '\n' : '\n\n';
      ta.value = val.slice(0,start) + insertText + val.slice(end);
      const newPos = start + insertText.length; ta.selectionStart = ta.selectionEnd = newPos; onChange();
    }
  });
}
function showPostloguePanel(show){ const p = byId('postloguePanel'); if(p) p.style.display = show ? 'block' : 'none'; }

function applyEpilogueToRenderArea(prefs){
  const area = byId('renderArea'); if(!area) return;
  // Remove existing epilogue block
  area.querySelectorAll(':scope > .chart-epilogue').forEach(n=> n.remove());
  const { html, autoConvert } = (prefs || loadPostloguePrefs());
  const content = html || '';
  if(!content || !content.trim()) return;
  const block = document.createElement('div'); block.className = 'chart-epilogue';
  const frag = convertTextOrHtmlToNodes(content, !!autoConvert);
  block.appendChild(frag);
  // Insert epilogue at the very end of render area
  area.appendChild(block);
}
/* ===== ListRef (hide/style/order) controls ===== */
function collectListRefLabelsFromRendered(area){
  const nodes = Array.from(area.querySelectorAll('.interlinear .pair.listRef[data-listref]'));
  const set = new Set();
  nodes.forEach(n=>{ const v=(n.getAttribute('data-listref')||'').trim(); if(v && !set.has(v)) set.add(v); });
  // Preserve first-encounter order; do not alphabetize
  return Array.from(set);
}
// Derive a suggested global order based on most common contiguous listRef patterns in the source XML
function computeListRefSuggestedOrderFromXml(xmlDoc){
  try{
    const runs = [];
    const mains = Array.from(xmlDoc.querySelectorAll('chart > row > cell > main'));
    mains.forEach(m => {
      const kids = Array.from(m.children || []);
      let i = 0;
      while(i < kids.length){
        if(kids[i].nodeName === 'listRef' || kids[i].nodeName === 'listref'){
          const run = [];
          let j = i;
          while(j < kids.length && (kids[j].nodeName === 'listRef' || kids[j].nodeName === 'listref')){
            const label = (kids[j].textContent || '').trim();
            if(label) run.push(label);
            j++;
          }
          if(run.length > 1) runs.push(run);
          i = j;
        } else {
          i++;
        }
      }
    });
  const labelsSet = new Set();
  const firstSeen = {};
  runs.forEach(r => r.forEach(l => { if(!labelsSet.has(l)){ firstSeen[l] = Object.keys(firstSeen).length; labelsSet.add(l); } }));
  const labels = Array.from(labelsSet);
    if(labels.length === 0) return [];
    // Pairwise precedence counts
    const wins = {}; const losses = {};
    labels.forEach(l => { wins[l] = {}; losses[l] = {}; labels.forEach(o => { wins[l][o] = 0; losses[l][o] = 0; }); });
    runs.forEach(run => {
      for(let a=0; a<run.length; a++){
        for(let b=a+1; b<run.length; b++){
          const x = run[a], y = run[b];
          if(x === y) continue;
          wins[x][y] = (wins[x][y]||0) + 1;
          losses[y][x] = (losses[y][x]||0) + 1;
        }
      }
    });
    const score = l => {
      let w = 0, d = 0;
      Object.keys(wins[l]||{}).forEach(k => { w += wins[l][k]||0; d += losses[l][k]||0; });
      return w - d;
    };
    const suggested = labels.sort((a,b)=>{
      const sa = score(a), sb = score(b);
      if(sb !== sa) return sb - sa; // higher score first (earlier)
      // Tie-breaker: first-seen order in XML, not alphabetical
      return (firstSeen[a]||0) - (firstSeen[b]||0);
    });
    return suggested;
  }catch(_){ return []; }
}
function loadListRefPrefs(){
  const d = loadJSON(LISTREF_PREFS_KEY) || {};
  return {
    entries: d.entries || {},
    order: Array.isArray(d.order) ? d.order : [],
    enforce: typeof d.enforce === 'boolean' ? d.enforce : undefined,
    enforceMode: d.enforceMode || (typeof d.enforce === 'boolean' ? (d.enforce ? 'global' : 'none') : 'global'),
    reverse: !!d.reverse,
    groups: Array.isArray(d.groups) ? d.groups : [] // [{id,name,order:[], styles:{hidden,bold,italic,underline,fontSize,color}}]
  };
}
function saveListRefPrefs(p){ saveJSON(LISTREF_PREFS_KEY, p); }
function reconcileListRefPrefs(prefs, labels, suggestedOrder){
  const out = { entries: { ...prefs.entries }, order: Array.from(prefs.order||[]), enforceMode: ['none','groups','global'].includes(prefs.enforceMode) ? prefs.enforceMode : 'global', reverse: !!prefs.reverse, groups: Array.isArray(prefs.groups) ? prefs.groups.map(g=>({...g})) : [] };
  // Remove stale entries
  Object.keys(out.entries).forEach(k=>{ if(!labels.includes(k)) delete out.entries[k]; });
  // Helper: normalize an entry so unset values are truly undefined
  function normalizeEntry(e){ if(!e) return e; ['hidden','bold','italic','underline'].forEach(k=>{ if(e[k] === false) delete e[k]; }); if(e.fontSize === '') delete e.fontSize; if(e.color === '') delete e.color; return e; }
  Object.keys(out.entries).forEach(k=>{ out.entries[k] = normalizeEntry(out.entries[k]); });
  // Add new labels with defaults
  labels.forEach(l=>{ if(!out.entries[l]) out.entries[l] = {}; });
  // Determine base order: prefer saved order; else suggested; else alphabetical
  let base = out.order && out.order.length ? out.order.slice() : (Array.isArray(suggestedOrder) && suggestedOrder.length ? suggestedOrder.slice() : labels.slice());
  // Compact to labels set and append any missing labels
  const ordered = base.filter(x => labels.includes(x));
  labels.forEach(l=>{ if(!ordered.includes(l)) ordered.push(l); });
  out.order = ordered;
  // Remove group members that no longer exist
  out.groups.forEach(g=>{ if(Array.isArray(g.order)) g.order = g.order.filter(x=> labels.includes(x)); });
  return out;
}
function showListRefPanel(show){ const p = byId('listRefPanel'); if(p) p.style.display = show ? 'block':'none'; }
function buildListRefControls(labels, suggestedOrder){
  const panel = byId('listRefPanel'); if(!panel) return;
  const rowsHost = byId('listRefRows');
  const groupsHost = byId('listRefGroupList');
  const resetBtn = byId('listRefResetOrder');
  const enforceSel = byId('listRefEnforceMode');
  const dirBtn = byId('listRefToggleOrder');
  const showAllBtn = byId('listRefShowAll');
  const hideAllBtn = byId('listRefHideAll');
  const resetAllStylesBtn = byId('listRefResetAllStyles');
  const addGroupBtn = byId('listRefAddGroup');
  const newGroupNameIn = byId('listRefNewGroupName');
  let prefs = reconcileListRefPrefs(loadListRefPrefs(), labels, suggestedOrder||[]);
  globalState.listRefPrefs = prefs; saveListRefPrefs(prefs);
  if(enforceSel){ enforceSel.value = prefs.enforceMode || 'global'; enforceSel.addEventListener('change', ()=>{ prefs.enforceMode = enforceSel.value; persist(); applyListRefPrefsToArea(); }); }
  function updateDirButton(){ if(dirBtn) dirBtn.textContent = prefs.reverse ? '(bottom → top)' : '(top → bottom)'; }
  if(dirBtn){ dirBtn.addEventListener('click', ()=>{ prefs.reverse = !prefs.reverse; persist(); applyListRefPrefsToArea(); updateDirButton(); }); }
  updateDirButton();
  if(showAllBtn){ showAllBtn.addEventListener('click', ()=>{ Object.values(prefs.entries).forEach(e=> e.hidden=false); persist(); applyListRefPrefsToArea(); renderRows(); }); }
  if(hideAllBtn){ hideAllBtn.addEventListener('click', ()=>{ Object.values(prefs.entries).forEach(e=> e.hidden=true); persist(); applyListRefPrefsToArea(); renderRows(); }); }
  if(resetAllStylesBtn){ resetAllStylesBtn.addEventListener('click', ()=>{
    Object.values(prefs.entries).forEach(e=>{ e.bold=false; e.italic=false; e.underline=false; e.fontSize=''; e.color=''; });
    (prefs.groups||[]).forEach(g=>{ g.styles = g.styles || {}; g.styles.bold=false; g.styles.italic=false; g.styles.underline=false; g.styles.fontSize=''; g.styles.color=''; });
    persist(); applyListRefPrefsToArea(); renderRows();
  }); }
  if(addGroupBtn){ addGroupBtn.addEventListener('click', ()=>{
    const name = (newGroupNameIn?.value || '').trim() || 'Group';
    const id = 'g_' + Date.now().toString(36) + '_' + Math.floor(Math.random()*1000);
    const g = { id, name, order: [], styles: { hidden:false, bold:false, italic:false, underline:false, fontSize:'', color:'' } };
    prefs.groups = Array.isArray(prefs.groups) ? prefs.groups : [];
    prefs.groups.push(g);
    if(newGroupNameIn) newGroupNameIn.value = '';
    persist(); renderRows(); applyListRefPrefsToArea();
  }); }
  function renderRows(){
    rowsHost.innerHTML='';
    const groupedIds = new Set();
    // Render groups first
    if(groupsHost){
      groupsHost.innerHTML = '';
      (prefs.groups||[]).forEach((g, gi)=>{
        const groupDiv = document.createElement('div'); groupDiv.className='lr-group';
        const header = document.createElement('div'); header.className='lr-group-header';
        const nameIn = document.createElement('input'); nameIn.type='text'; nameIn.placeholder='Group name'; nameIn.value = g.name||''; nameIn.style.padding='4px 6px'; nameIn.style.border='1px solid #e5e5e5'; nameIn.style.borderRadius='6px';
        nameIn.addEventListener('input', ()=>{ g.name = nameIn.value; persist(); });
        const upBtn = document.createElement('button'); upBtn.className='small-btn secondary'; upBtn.textContent='↑'; upBtn.title='Move group earlier';
        const dnBtn = document.createElement('button'); dnBtn.className='small-btn secondary'; dnBtn.textContent='↓'; dnBtn.title='Move group later';
        upBtn.addEventListener('click', ()=>{ moveGroup(gi,-1); }); dnBtn.addEventListener('click', ()=>{ moveGroup(gi,1); });
        // Group style controls
        const hideBtn = document.createElement('button'); hideBtn.className='small-btn'; hideBtn.title='Toggle group visibility';
  g.styles = g.styles || {};
        function setHideIcon(){ hideBtn.textContent = g.styles.hidden ? '🙈' : '👁️'; }
        setHideIcon();
  hideBtn.addEventListener('click', ()=>{ if(g.styles.hidden){ delete g.styles.hidden; } else { g.styles.hidden = true; } setHideIcon(); persist(); applyListRefPrefsToArea(); renderRows(); });
  const b = mkToggle('B', 'Bold', !!g.styles.bold, v=>{ if(v) g.styles.bold=true; else delete g.styles.bold; persist(); applyListRefPrefsToArea(); });
  const i = mkToggle('I', 'Italic', !!g.styles.italic, v=>{ if(v) g.styles.italic=true; else delete g.styles.italic; persist(); applyListRefPrefsToArea(); });
  const u = mkToggle('U', 'Underline', !!g.styles.underline, v=>{ if(v) g.styles.underline=true; else delete g.styles.underline; persist(); applyListRefPrefsToArea(); });
        const sizeIn = document.createElement('input'); sizeIn.type='number'; sizeIn.placeholder='size px'; sizeIn.min='8'; sizeIn.max='48'; sizeIn.step='1'; sizeIn.style.width='84px'; sizeIn.value = g.styles.fontSize||'';
  sizeIn.addEventListener('input', ()=>{ if(sizeIn.value) g.styles.fontSize = sizeIn.value; else delete g.styles.fontSize; persist(); applyListRefPrefsToArea(); });
  const colorIn = document.createElement('input'); colorIn.type='color'; colorIn.value = g.styles.color || '#000000'; colorIn.title = 'Text color'; colorIn.addEventListener('input', ()=>{ if(colorIn.value) g.styles.color = colorIn.value; else delete g.styles.color; persist(); applyListRefPrefsToArea(); });
        const colorWrap = document.createElement('span'); colorWrap.className='lr-chip'; colorWrap.title='Text color'; colorWrap.appendChild(colorIn);
        const sizeWrap = document.createElement('span'); sizeWrap.className='lr-chip'; sizeWrap.title='Font size (px)'; sizeWrap.appendChild(sizeIn);
        // Remove group
        const resetStyleBtn = document.createElement('button'); resetStyleBtn.className='small-btn secondary'; resetStyleBtn.textContent='Reset style'; resetStyleBtn.title='Clear visibility and styles for this group and its items';
        resetStyleBtn.addEventListener('click', ()=>{
          // Clear group styles including visibility
          g.styles = {};
          // Also clear individual styles/visibility for items in this group
          (g.order||[]).forEach(id=>{ const e=prefs.entries[id]; if(e){ delete e.hidden; delete e.bold; delete e.italic; delete e.underline; delete e.fontSize; delete e.color; } });
          persist(); applyListRefPrefsToArea(); renderRows();
        });
  const del = document.createElement('button'); del.className='small-btn secondary'; del.textContent='Remove group'; del.addEventListener('click', ()=>{ prefs.groups.splice(gi,1); persist(); renderRows(); applyListRefPrefsToArea(); });
  header.appendChild(upBtn); header.appendChild(dnBtn); header.appendChild(nameIn); header.appendChild(hideBtn); header.appendChild(b); header.appendChild(i); header.appendChild(u); header.appendChild(sizeWrap); header.appendChild(colorWrap); header.appendChild(resetStyleBtn); header.appendChild(del);
        groupDiv.appendChild(header);
        // Items: ordered rows with membership toggle, up/down, and per-item style controls
        const itemsDiv = document.createElement('div'); itemsDiv.className='lr-group-items';
        const allIds = prefs.order.filter(id=> labels.includes(id));
        g.order = Array.isArray(g.order) ? g.order.filter(id=> allIds.includes(id)) : [];
        const inGroup = new Set(g.order);
        // Membership selector to add new items into group
        const addWrap = document.createElement('div'); addWrap.style.marginBottom='6px';
        const addSelect = document.createElement('select'); addSelect.title='Add item to group';
        const defaultOpt = document.createElement('option'); defaultOpt.value=''; defaultOpt.textContent='Add item to group…'; addSelect.appendChild(defaultOpt);
        allIds.forEach(id=>{ if(inGroup.has(id)) return; const opt=document.createElement('option'); opt.value=id; opt.textContent=id; addSelect.appendChild(opt); });
        addSelect.addEventListener('change', ()=>{
          const id = addSelect.value; if(!id) return; g.order.push(id); persist(); applyListRefPrefsToArea(); renderRows(); });
        addWrap.appendChild(addSelect); itemsDiv.appendChild(addWrap);
        // Render existing members in g.order
        g.order.forEach((id, idx)=>{
          groupedIds.add(id);
          const ent = prefs.entries[id]; if(!ent) return;
          const row = document.createElement('div'); row.className='lr-row';
          const upBtn = document.createElement('button'); upBtn.className='small-btn secondary'; upBtn.textContent='↑'; upBtn.title='Move earlier';
          const dnBtn = document.createElement('button'); dnBtn.className='small-btn secondary'; dnBtn.textContent='↓'; dnBtn.title='Move later';
          upBtn.addEventListener('click', ()=>{ moveInGroup(gi, idx, -1); });
          dnBtn.addEventListener('click', ()=>{ moveInGroup(gi, idx, +1); });
          row.appendChild(upBtn); row.appendChild(dnBtn);
          const abbr = document.createElement('span'); abbr.className='lr-abbr'; abbr.textContent=id; row.appendChild(abbr);
          const styleControls = document.createElement('div'); styleControls.style.display='flex'; styleControls.style.alignItems='center'; styleControls.style.gap='8px';
          const hideBtn = document.createElement('button'); hideBtn.className='small-btn'; hideBtn.title='Toggle visibility';
          function setHideIcon(){ hideBtn.textContent = ent.hidden ? '🙈' : '👁️'; }
          setHideIcon();
          hideBtn.addEventListener('click', ()=>{ if(ent.hidden){ delete ent.hidden; } else { ent.hidden = true; } setHideIcon(); persist(); applyListRefPrefsToArea(); renderRows(); });
          styleControls.appendChild(hideBtn);
          const b = mkToggle('B', 'Bold', !!ent.bold, v=>{ if(v) ent.bold=true; else delete ent.bold; persist(); applyListRefPrefsToArea(); });
          const i = mkToggle('I', 'Italic', !!ent.italic, v=>{ if(v) ent.italic=true; else delete ent.italic; persist(); applyListRefPrefsToArea(); });
          const u = mkToggle('U', 'Underline', !!ent.underline, v=>{ if(v) ent.underline=true; else delete ent.underline; persist(); applyListRefPrefsToArea(); });
          const sizeIn = document.createElement('input'); sizeIn.type='number'; sizeIn.placeholder='size px'; sizeIn.min='8'; sizeIn.max='48'; sizeIn.step='1'; sizeIn.style.width='84px'; sizeIn.value = ent.fontSize || '';
          sizeIn.addEventListener('input', ()=>{ if(sizeIn.value) ent.fontSize = sizeIn.value; else delete ent.fontSize; persist(); applyListRefPrefsToArea(); });
          const colorIn = document.createElement('input'); colorIn.type='color'; colorIn.value = ent.color || '#000000'; colorIn.title = 'Text color'; colorIn.addEventListener('input', ()=>{ if(colorIn.value) ent.color = colorIn.value; else delete ent.color; persist(); applyListRefPrefsToArea(); });
          const sizeWrap = document.createElement('span'); sizeWrap.className='lr-chip'; sizeWrap.title='Font size (px)'; sizeWrap.appendChild(sizeIn);
          const colorWrap = document.createElement('span'); colorWrap.className='lr-chip'; colorWrap.title='Text color'; colorWrap.appendChild(colorIn);
          const resetStyleBtn = document.createElement('button'); resetStyleBtn.className='small-btn secondary'; resetStyleBtn.textContent='Reset style'; resetStyleBtn.title='Clear visibility and styles for this item';
          resetStyleBtn.addEventListener('click', ()=>{ delete ent.hidden; delete ent.bold; delete ent.italic; delete ent.underline; delete ent.fontSize; delete ent.color; persist(); applyListRefPrefsToArea(); renderRows(); });
          // Remove from group
          const removeBtn = document.createElement('button'); removeBtn.className='small-btn secondary'; removeBtn.textContent='Remove from group'; removeBtn.addEventListener('click', ()=>{ g.order.splice(idx,1); persist(); applyListRefPrefsToArea(); renderRows(); });
          styleControls.appendChild(b); styleControls.appendChild(i); styleControls.appendChild(u); styleControls.appendChild(sizeWrap); styleControls.appendChild(colorWrap); styleControls.appendChild(resetStyleBtn); styleControls.appendChild(removeBtn);
          row.appendChild(styleControls);
          itemsDiv.appendChild(row);
        });
        groupDiv.appendChild(itemsDiv);
        groupsHost.appendChild(groupDiv);
      });
    }
    // Then render ungrouped items in the main list
    prefs.order.forEach(label=>{
      if(groupedIds.has(label)) return;
      const ent = prefs.entries[label]; if(!ent) return;
      const row = document.createElement('div'); row.className = 'lr-row';
      // Up/Down before abbreviation
      const upBtn = document.createElement('button'); upBtn.className='small-btn secondary'; upBtn.textContent='↑'; upBtn.title='Move earlier';
      const dnBtn = document.createElement('button'); dnBtn.className='small-btn secondary'; dnBtn.textContent='↓'; dnBtn.title='Move later';
      upBtn.addEventListener('click', ()=>{ move(label, -1); }); dnBtn.addEventListener('click', ()=>{ move(label, +1); });
      row.appendChild(upBtn); row.appendChild(dnBtn);
      // Abbreviation next
      const abbr = document.createElement('span'); abbr.className = 'lr-abbr'; abbr.textContent = label; row.appendChild(abbr);
      const styleControls = document.createElement('div');
      styleControls.style.display='flex'; styleControls.style.alignItems='center'; styleControls.style.gap='8px';
      // Hide as first style option (eye icon)
      const hideBtn = document.createElement('button'); hideBtn.className='small-btn'; hideBtn.title='Toggle visibility';
      function setHideIcon(){ hideBtn.textContent = ent.hidden ? '🙈' : '👁️'; }
      setHideIcon();
  hideBtn.addEventListener('click', ()=>{ if(ent.hidden){ delete ent.hidden; } else { ent.hidden = true; } setHideIcon(); persist(); applyListRefPrefsToArea(); renderHiddenVisual(); renderRows(); });
      styleControls.appendChild(hideBtn);
  const b = mkToggle('B', 'Bold', !!ent.bold, v=>{ if(v) ent.bold=true; else delete ent.bold; persist(); applyListRefPrefsToArea(); });
  const i = mkToggle('I', 'Italic', !!ent.italic, v=>{ if(v) ent.italic=true; else delete ent.italic; persist(); applyListRefPrefsToArea(); });
  const u = mkToggle('U', 'Underline', !!ent.underline, v=>{ if(v) ent.underline=true; else delete ent.underline; persist(); applyListRefPrefsToArea(); });
      const sizeIn = document.createElement('input'); sizeIn.type='number'; sizeIn.placeholder='size px'; sizeIn.min='8'; sizeIn.max='48'; sizeIn.step='1';
      sizeIn.value = ent.fontSize || '';
      sizeIn.style.width='84px';
  sizeIn.addEventListener('input', ()=>{ if(sizeIn.value) ent.fontSize = sizeIn.value; else delete ent.fontSize; persist(); applyListRefPrefsToArea(); });
  const colorIn = document.createElement('input'); colorIn.type='color'; colorIn.value = ent.color || '#000000'; colorIn.title = 'Text color'; colorIn.addEventListener('input', ()=>{ if(colorIn.value) ent.color = colorIn.value; else delete ent.color; persist(); applyListRefPrefsToArea(); });
      styleControls.appendChild(b); styleControls.appendChild(i); styleControls.appendChild(u);
  const sizeWrap = document.createElement('span'); sizeWrap.className='lr-chip'; sizeWrap.title='Font size (px)'; sizeWrap.appendChild(sizeIn);
      const colorWrap = document.createElement('span'); colorWrap.className='lr-chip'; colorWrap.title='Text color'; colorWrap.appendChild(colorIn);
  const resetStyleBtn = document.createElement('button'); resetStyleBtn.className='small-btn secondary'; resetStyleBtn.textContent='Reset style'; resetStyleBtn.title='Clear visibility and styles for this item';
  resetStyleBtn.addEventListener('click', ()=>{ delete ent.hidden; delete ent.bold; delete ent.italic; delete ent.underline; delete ent.fontSize; delete ent.color; persist(); applyListRefPrefsToArea(); renderHiddenVisual(); renderRows(); });
  styleControls.appendChild(sizeWrap);
      styleControls.appendChild(colorWrap);
  styleControls.appendChild(resetStyleBtn);
      row.appendChild(styleControls);
      function renderHiddenVisual(){ if(ent.hidden) abbr.classList.add('is-hidden'); else abbr.classList.remove('is-hidden'); }
      renderHiddenVisual();
      rowsHost.appendChild(row);
    });
  }
  function mkToggle(txt, title, on, cb){ const b = document.createElement('button'); b.className='small-btn'; b.textContent=txt; b.title=title; b.style.fontWeight= on?'700':'400'; b.style.textDecoration = txt==='U' && on ? 'underline':'none'; b.style.fontStyle = txt==='I' && on ? 'italic':'normal'; b.addEventListener('click', ()=>{ const v = !(txt==='B'? (b.style.fontWeight==='700') : txt==='I' ? (b.style.fontStyle==='italic') : (b.style.textDecoration==='underline')); if(txt==='B') b.style.fontWeight = v?'700':'400'; if(txt==='I') b.style.fontStyle = v?'italic':'normal'; if(txt==='U') b.style.textDecoration = v?'underline':'none'; cb(v); }); return b; }
  function move(label, delta){ const idx = prefs.order.indexOf(label); const j = idx + delta; if(j<0||j>=prefs.order.length) return; const t=prefs.order[idx]; prefs.order[idx]=prefs.order[j]; prefs.order[j]=t; persist(); renderRows(); applyListRefPrefsToArea(); }
  function moveInGroup(gi, idx, delta){ const g=prefs.groups[gi]; if(!g||!Array.isArray(g.order)) return; const j = idx + delta; if(j<0||j>=g.order.length) return; const t=g.order[idx]; g.order[idx]=g.order[j]; g.order[j]=t; persist(); renderRows(); applyListRefPrefsToArea(); }
  function moveGroup(gi, delta){ const j = gi + delta; if(j<0||j>=prefs.groups.length) return; const t=prefs.groups[gi]; prefs.groups[gi]=prefs.groups[j]; prefs.groups[j]=t; persist(); renderRows(); applyListRefPrefsToArea(); }
  function persist(){ globalState.listRefPrefs = prefs; saveListRefPrefs(prefs); }
  renderRows();
  // apply immediately
  applyListRefPrefsToArea();
  // Wire Reset order: recompute suggestion from current XML and apply
  if(resetBtn && panel.dataset.resetWired !== '1'){
    resetBtn.addEventListener('click', ()=>{
      try{
        // Recompute suggested from last XML in memory is not stored; call compute on window XML via last transform input
        // We don't have the last xmlDoc stored globally; instead, re-derive labels suggestion from the same XML we used earlier.
        // As a practical approach, we will use the last computed suggestedOrder passed in, or recompute from Abbrev XML if available.
        // Since suggestedOrder is passed into this builder, prefer reusing it.
        const suggestion = Array.isArray(suggestedOrder) ? suggestedOrder.slice() : [];
        // Clear saved order and adopt suggestion
        prefs.order = reconcileListRefPrefs({ entries: prefs.entries, order: [] }, labels, suggestion).order;
        persist();
        renderRows();
        applyListRefPrefsToArea();
      }catch(_){ /* no-op */ }
    });
    panel.dataset.resetWired = '1';
  }
}
function applyListRefPrefsToArea(){
  const area = byId('renderArea'); if(!area) return;
  const prefs = globalState.listRefPrefs || loadListRefPrefs();
  // For each interlinear cell, reorder contiguous runs of listRef pairs based on prefs.order (if enforce enabled)
  const cells = Array.from(area.querySelectorAll('.interlinear'));
  cells.forEach(cell=>{
    // collect siblings and identify listRef pairs
    const pairs = Array.from(cell.querySelectorAll(':scope > .pair'));
    // Walk and process runs of listRef pairs
    let i=0; while(i < pairs.length){
      if(!pairs[i].classList.contains('listRef')){ i++; continue; }
      let j=i; const run=[]; while(j<pairs.length && pairs[j].classList.contains('listRef')){ run.push(pairs[j]); j++; }
      const mode = prefs.enforceMode || (typeof prefs.enforce === 'boolean' ? (prefs.enforce ? 'global' : 'none') : 'global');
      if(mode !== 'none'){
        // Ensure we keep original order metadata for later restoration
        run.forEach((n, idx)=>{ if(!n.hasAttribute('data-orig-index')) n.setAttribute('data-orig-index', String(idx)); });
        // sort run by prefs.order using each node's data-listref
        // If groups are defined and a token is a member of a group, rank by group order first (index of group), then within-group order, then fallback to global order (only when mode==='global')
        const groupIndexFor = (lab)=>{
          const groups = prefs.groups||[];
          for(let gi=0; gi<groups.length; gi++){
            const g = groups[gi];
            if(Array.isArray(g.order) && g.order.includes(lab)) return gi;
          }
          return Number.MAX_SAFE_INTEGER;
        };
        const inGroupPos = (lab)=>{
          const groups = prefs.groups||[];
          for(let gi=0; gi<groups.length; gi++){
            const g = groups[gi];
            if(Array.isArray(g.order)){
              const k = g.order.indexOf(lab);
              if(k !== -1) return k;
            }
          }
          return Number.MAX_SAFE_INTEGER;
        };
        const globalIndex = (lab)=>{ const k=(lab||'').trim(); const idx=prefs.order.indexOf(k); return idx===-1? Number.MAX_SAFE_INTEGER: idx; };
        // In groups-only mode, we only sort within adjacent clusters of the same group.
        run.sort((a,b)=>{
          const la = (a.getAttribute('data-listref')||'').trim();
          const lb = (b.getAttribute('data-listref')||'').trim();
          const ga = groupIndexFor(la), gb = groupIndexFor(lb);
          if(ga !== gb){
            // Different groups or one ungrouped vs grouped: don't intermix in groups-only mode, keep original order for both
            if(mode === 'groups'){
              const oa = parseInt(a.getAttribute('data-orig-index')||'0',10);
              const ob = parseInt(b.getAttribute('data-orig-index')||'0',10);
              return oa - ob;
            }
            return ga - gb;
          }
          const pa = inGroupPos(la), pb = inGroupPos(lb);
          if(pa !== pb){
            if(mode === 'groups') return pa - pb; // same group cluster: apply within-group order
            return pa - pb;
          }
          if(mode === 'groups'){
            // identical positions (likely same token or ambiguous), keep source order
            const oa = parseInt(a.getAttribute('data-orig-index')||'0',10);
            const ob = parseInt(b.getAttribute('data-orig-index')||'0',10);
            return oa - ob;
          }
          return globalIndex(la) - globalIndex(lb);
        });
        if(prefs.reverse) run.reverse();
        // reinsert in DOM in this new order
        const before = pairs[j] || null; // node after run
        run.forEach(n=> cell.insertBefore(n, before));
      } else {
        // Restore to original XML order using data-orig-index (fallback to current order if not present)
        run.forEach((n, idx)=>{ if(!n.hasAttribute('data-orig-index')) n.setAttribute('data-orig-index', String(idx)); });
        run.sort((a,b)=> (parseInt(a.getAttribute('data-orig-index')||'0',10) - parseInt(b.getAttribute('data-orig-index')||'0',10)) );
        if(prefs.reverse) run.reverse();
        const before = pairs[j] || null;
        run.forEach(n=> cell.insertBefore(n, before));
      }
      i = j; // advance
    }
  });
  // In groups-only mode, surface warnings for group members that are not adjacent within a run
  try{
    const mode = (globalState.listRefPrefs || {}).enforceMode || 'global';
    const warnHost = byId('listRefWarnings');
    if(warnHost){ warnHost.style.display='none'; warnHost.innerHTML=''; }
    if(mode === 'groups'){
      const runs = [];
      const cells2 = Array.from(area.querySelectorAll('.interlinear'));
      cells2.forEach(cell=>{
        const pairs2 = Array.from(cell.querySelectorAll(':scope > .pair'));
        let i2=0; while(i2<pairs2.length){
          if(!pairs2[i2].classList.contains('listRef')){ i2++; continue; }
          let j2=i2; const runNodes=[]; while(j2<pairs2.length && pairs2[j2].classList.contains('listRef')){ runNodes.push(pairs2[j2]); j2++; }
          // Derive row/column context
          const td = cell.closest('td,th');
          let tr = null, col = 0, rowLabel = '';
          if(td){
            tr = td.parentElement;
            const cellsInRow = Array.from(tr.children);
            col = cellsInRow.indexOf(td) + 1;
            const firstCell = cellsInRow[0];
            if(firstCell){ rowLabel = (firstCell.textContent || '').trim(); }
          }
          runs.push({ nodes: runNodes, rowLabel, col });
          i2=j2;
        }
      });
      const problems = [];
      (globalState.listRefPrefs.groups||[]).forEach(g=>{
        if(!Array.isArray(g.order) || g.order.length<2) return;
        runs.forEach(run=>{
          const present = g.order.filter(id=> run.nodes.some(n => (n.getAttribute('data-listref')||'').trim() === id));
          if(present.length >= 2){
            // Check adjacency in the run
            const indices = present.map(id => run.nodes.findIndex(n => (n.getAttribute('data-listref')||'').trim() === id)).sort((a,b)=>a-b);
            // If any consecutive desired members are separated by others, warn
            for(let k=1;k<indices.length;k++){
              if(indices[k] !== indices[k-1]+1){
                problems.push({ group: g.name || '(unnamed group)', ids: present, row: run.rowLabel || '(row)', col: run.col });
                break;
              }
            }
          }
        });
      });
      if(problems.length && warnHost){
        const uniq = [];
        const seen = new Set();
        problems.forEach(p=>{ const key=p.group+':' + p.ids.join('|') + ':' + p.row + ':' + p.col; if(!seen.has(key)){ seen.add(key); uniq.push(p); } });
        warnHost.style.display='block';
        warnHost.innerHTML = 'Note: Some group members are not adjacent in the source. Consider adjusting the sequence in FLEx if strict adjacency matters.' +
          '<br>' + uniq.map(p => `• Group ${escapeHtml(p.group)} at row ${escapeHtml(p.row)}, column ${p.col}: ${p.ids.map(escapeHtml).join(', ')}`).join('<br>');
      }
    }
  }catch(_){/* non-fatal */}
  // Apply style/visibility per label, including group-level overrides (group styles apply first, item styles override when set)
  const nodes = Array.from(area.querySelectorAll('.interlinear .pair.listRef[data-listref]'));
  nodes.forEach(n=>{
    const lab = (n.getAttribute('data-listref')||'').trim(); const ent = prefs.entries && prefs.entries[lab];
    // Resolve group membership and styles
    let gstyles = {};
    const g = (prefs.groups||[]).find(g=> Array.isArray(g.order) && g.order.includes(lab));
    if(g && g.styles) gstyles = { ...gstyles, ...g.styles };
    const final = { ...gstyles };
    if(ent){
      ['hidden','bold','italic','underline','fontSize','color'].forEach(k=>{
        if(ent[k] !== undefined && ent[k] !== '' && ent[k] !== null) final[k] = ent[k];
      });
    }
    n.style.display = final.hidden ? 'none' : '';
    const w = n.querySelector(':scope > .w'); if(w){
      w.style.fontWeight = final.bold ? '700' : '';
      w.style.fontStyle = final.italic ? 'italic' : '';
      w.style.textDecoration = final.underline ? 'underline' : '';
      w.style.fontSize = final.fontSize ? (parseInt(final.fontSize,10)||0) + 'px' : '';
      w.style.color = final.color || '';
    }
  });
}
/* ===== Abbreviations (listRef) controls and render ===== */
function collectListRefLabelsFromXml(xmlDoc){
  if(!xmlDoc) return [];
  const nodes = Array.from(xmlDoc.getElementsByTagName('listRef'));
  const set = new Set();
  nodes.forEach(n=>{
    const t = (n.textContent || '').trim();
    if(t) set.add(t);
  });
  return Array.from(set).sort((a,b)=> a.localeCompare(b, undefined, { numeric:true, sensitivity:'base' }));
}
function loadAbbrevPrefs(){
  const d = loadJSON(ABBREV_PREFS_KEY) || {};
  return {
    include: typeof d.include === 'boolean' ? d.include : true,
    position: d.position === 'bottom' ? 'bottom' : 'top',
    entries: d.entries || {}
  };
}
function saveAbbrevPrefs(p){ saveJSON(ABBREV_PREFS_KEY, p); }
function reconcileAbbrevPrefsWithLabels(prefs, labels){
  const out = { include: prefs.include, position: prefs.position, entries: { ...prefs.entries } };
  // Remove stale CHART entries; keep MANUAL ones always
  Object.keys(out.entries).forEach(k=>{
    const e = out.entries[k] || {};
    const isManual = e.src === 'manual' || String(k).startsWith('__manual__');
    if(!isManual){
      // chart-sourced entries are removed if no longer present
      if(!labels.includes(e.abbr || k)) delete out.entries[k];
    }
  });
  // Ensure entry for each label
  labels.forEach(l=>{
    const existing = out.entries[l] || Object.values(out.entries).find(e => e.abbr === l && e.src !== 'manual');
    if(!existing){
      out.entries[l] = { abbr: l, name: '', def: '', src: 'chart' };
    } else {
      // migrate legacy shape {label, def} where label was previously editable: treat it as name
      const e = existing;
      if(e.label !== undefined && e.name === undefined){ e.name = e.label || ''; delete e.label; }
      if(e.abbr === undefined) e.abbr = l;
      if(e.def === undefined) e.def = '';
      if(e.src === undefined) e.src = 'chart';
      // If existing is not keyed by l, re-key it
      if(!out.entries[l]){
        // find its key
        const kFound = Object.keys(out.entries).find(k => out.entries[k] === e);
        if(kFound && kFound !== l){ delete out.entries[kFound]; out.entries[l] = e; }
      }
    }
  });
  return out;
}
function showAbbrevPanel(show){ byId('abbrevPanel').style.display = show ? 'block' : 'none'; }
function buildAbbrevControls(labels){
  const panel = byId('abbrevPanel'); if(!panel) return;
  const includeCb = byId('abbrevInclude');
  const posSel = byId('abbrevPosition');
  const rowsHost = byId('abbrevRows');
  const emptyMsg = byId('abbrevEmptyMsg');
  const resetBtn = byId('abbrevResetFromChart');
  const addBtn = byId('abbrevAddManual');
  globalState.abbrevPrefs = reconcileAbbrevPrefsWithLabels(loadAbbrevPrefs(), labels);
  includeCb.checked = !!globalState.abbrevPrefs.include;
  posSel.value = globalState.abbrevPrefs.position;
  function renderRows(){
    rowsHost.innerHTML = '';
    const keys = Object.keys(globalState.abbrevPrefs.entries);
    emptyMsg.style.display = keys.length ? 'none' : 'block';
    keys.sort((a,b)=> a.localeCompare(b, undefined, {numeric:true,sensitivity:'base'})).forEach(k=>{
      const ent = globalState.abbrevPrefs.entries[k];
      const row = document.createElement('div'); row.className = 'abbr-row';
      let abbrCell;
      const isManual = ent.src === 'manual' || String(k).startsWith('__manual__');
      if(isManual){
        const abbrIn = document.createElement('input'); abbrIn.type = 'text'; abbrIn.value = ent.abbr || ''; abbrIn.placeholder = 'Abbreviation (incl. parentheses)';
        abbrIn.addEventListener('input', ()=>{
          ent.abbr = abbrIn.value;
          // If abbr is valid and unique, migrate key
          const trimmed = (ent.abbr || '').trim();
          if(trimmed && !globalState.abbrevPrefs.entries[trimmed]){
            delete globalState.abbrevPrefs.entries[k];
            globalState.abbrevPrefs.entries[trimmed] = ent;
            saveAbbrevPrefs(globalState.abbrevPrefs);
            renderRows();
            applyAbbrevToRenderArea(globalState.abbrevPrefs);
          } else {
            saveAbbrevPrefs(globalState.abbrevPrefs);
            applyAbbrevToRenderArea(globalState.abbrevPrefs);
          }
        });
        abbrCell = abbrIn;
      } else {
        const abbrEl = document.createElement('span'); abbrEl.className = 'abbr-abbr'; abbrEl.textContent = ent.abbr || k; abbrCell = abbrEl;
      }
      const nameIn = document.createElement('input'); nameIn.type = 'text'; nameIn.value = ent.name || ''; nameIn.placeholder = 'Name';
      const defIn = document.createElement('input'); defIn.type = 'text'; defIn.value = ent.def || ''; defIn.placeholder = 'Description (optional)';
      nameIn.addEventListener('input', ()=>{ ent.name = nameIn.value; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
      defIn.addEventListener('input', ()=>{ ent.def = defIn.value; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
      row.appendChild(abbrCell); row.appendChild(nameIn); row.appendChild(defIn);
      if(isManual){
        const delBtn = document.createElement('button'); delBtn.className = 'small-btn secondary'; delBtn.textContent = 'Remove';
        delBtn.addEventListener('click', ()=>{
          delete globalState.abbrevPrefs.entries[k];
          saveAbbrevPrefs(globalState.abbrevPrefs);
          renderRows();
          applyAbbrevToRenderArea(globalState.abbrevPrefs);
        });
        // make a 4th column for remove button
        row.style.gridTemplateColumns = 'auto 1fr 2fr auto';
        row.appendChild(delBtn);
      }
      rowsHost.appendChild(row);
    });
  }
  if(panel.dataset.wired !== '1'){
    includeCb.addEventListener('change', ()=>{ globalState.abbrevPrefs.include = !!includeCb.checked; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
    posSel.addEventListener('change', ()=>{ globalState.abbrevPrefs.position = posSel.value === 'bottom' ? 'bottom':'top'; saveAbbrevPrefs(globalState.abbrevPrefs); applyAbbrevToRenderArea(globalState.abbrevPrefs); });
    resetBtn.addEventListener('click', ()=>{
      globalState.abbrevPrefs = reconcileAbbrevPrefsWithLabels(globalState.abbrevPrefs, globalState.chartAbbrevLabels || []);
      saveAbbrevPrefs(globalState.abbrevPrefs); renderRows(); applyAbbrevToRenderArea(globalState.abbrevPrefs);
    });
    addBtn.addEventListener('click', ()=>{
      // create a placeholder manual entry with a temp key
      const tempKey = '__manual__' + Date.now() + '_' + Math.floor(Math.random()*10000);
      globalState.abbrevPrefs.entries[tempKey] = { abbr: '', name: '', def: '', src: 'manual' };
      saveAbbrevPrefs(globalState.abbrevPrefs);
      renderRows();
      applyAbbrevToRenderArea(globalState.abbrevPrefs);
    });
    panel.dataset.wired = '1';
  }
  saveAbbrevPrefs(globalState.abbrevPrefs);
  renderRows();
  // Apply immediately to current render
  applyAbbrevToRenderArea(globalState.abbrevPrefs);
}
function applyAbbrevToRenderArea(prefs){
  const area = byId('renderArea'); if(!area) return;
  // Remove any existing blocks
  area.querySelectorAll(':scope > .chart-abbrev-block').forEach(n=> n.remove());
  if(!prefs || !prefs.include) return;
  const entries = Object.values(prefs.entries || {});
  if(!entries.length) return;
  const block = document.createElement('div'); block.className = 'chart-abbrev-block';
  const heading = document.createElement('h3'); heading.textContent = 'Abbreviations'; block.appendChild(heading);
  const list = document.createElement('ul');
  entries
    .sort((a,b)=> (a.abbr||'').localeCompare(b.abbr||'', undefined, {numeric:true,sensitivity:'base'}))
    .forEach(ent=>{
      const li = document.createElement('li');
      const abbr = (ent.abbr || '').trim();
      const name = (ent.name || '').trim();
      const def = (ent.def || '').trim();
      if(!abbr) return; // must have abbreviation
      let tail = '';
      if(name && def) tail = ` — ${escapeHtml(name)} — ${escapeHtml(def)}`;
      else if(name) tail = ` — ${escapeHtml(name)}`;
      else if(def) tail = ` — ${escapeHtml(def)}`;
      li.innerHTML = `<strong>${escapeHtml(abbr)}</strong>${tail}`;
      list.appendChild(li);
    });
  if(!list.childNodes.length) return;
  block.appendChild(list);
  // Insert at chosen position
  const prologue = area.querySelector(':scope > .chart-prologue');
  const table = area.querySelector('table.chartshell')?.closest('.chartshell-wrapper') || area.querySelector('table.chartshell');
  if(prefs.position === 'top'){
    if(prologue && prologue.nextSibling) area.insertBefore(block, prologue.nextSibling);
    else area.insertBefore(block, area.firstChild || null);
  } else {
    if(table && table.nextSibling) area.insertBefore(block, table.nextSibling);
    else area.appendChild(block);
  }
}
function applyPrologueToRenderArea(prefs){
  const area = byId('renderArea');
  if(!area) return;
  // Ensure a fixed container exists as the first child for prologue content
  let prologue = area.querySelector(':scope > .chart-prologue');
  if(!prologue){
    prologue = document.createElement('div');
    prologue.className = 'chart-prologue';
    // Insert after any before-prologue HTML if present
    const beforeBlock = area.querySelector(':scope > .inserted-html-before-prologue');
    if(beforeBlock && beforeBlock.nextSibling){
      area.insertBefore(prologue, beforeBlock.nextSibling);
    } else if(beforeBlock){
      area.appendChild(prologue);
    } else {
      area.insertBefore(prologue, area.firstChild || null);
    }
  }
  prologue.innerHTML = '';
  const { tag, titleText } = (prefs || loadProloguePrefs());
  let { prefaceHtml, autoConvert } = (prefs || loadProloguePrefs());
  if(titleText && tag){
    const t = document.createElement(tag);
    t.textContent = titleText;
    prologue.appendChild(t);
  }
  if(prefaceHtml && prefaceHtml.trim()){
    const frag = convertTextOrHtmlToNodes(prefaceHtml, !!autoConvert);
    prologue.appendChild(frag);
  }
  // If both are empty, remove the container to avoid extra spacing
  if(!prologue.childNodes.length){ prologue.remove(); }
}

/* ===== Shared conversion helpers for Prologue/Epilogue ===== */
function hasAnyHtmlTag(s){ return /<\s*[a-zA-Z!\/?]/.test(s || ''); }
function hasBlockTag(s){ return /<\s*(p|div|section|article|header|footer|aside|main|nav|h[1-6]|ul|ol|li|table|thead|tbody|tfoot|tr|td|th|blockquote|pre|figure|figcaption)\b/i.test(s || ''); }
function isBlockElement(el){ if(!el || el.nodeType !== 1) return false; const n = el.nodeName.toLowerCase(); return (
  n==='p'||n==='div'||n==='section'||n==='article'||n==='header'||n==='footer'||n==='aside'||n==='main'||n==='nav'||/^h[1-6]$/.test(n)||n==='ul'||n==='ol'||n==='li'||n==='table'||n==='thead'||n==='tbody'||n==='tfoot'||n==='tr'||n==='td'||n==='th'||n==='blockquote'||n==='pre'||n==='figure'||n==='figcaption'
); }
function cleanupAutoConvertedHtml(container){
  // Unwrap <p> that directly wrap a single block element
  Array.from(container.querySelectorAll('p')).forEach(p=>{
    const kids = Array.from(p.childNodes).filter(n=> n.nodeType===1 || (n.nodeType===3 && n.nodeValue.trim()));
    if(kids.length===1 && isBlockElement(kids[0])){
      p.replaceWith(kids[0]);
    }
  });
  // Unwrap <p> that contains only <br> (and whitespace)
  Array.from(container.querySelectorAll('p')).forEach(p=>{
    const meaningful = Array.from(p.childNodes).filter(n=> n.nodeType===1 || (n.nodeType===3 && n.nodeValue.trim()));
    const onlyBrs = meaningful.length>0 && meaningful.every(n => n.nodeType===1 && n.nodeName==='BR');
    if(onlyBrs){
      const frag = document.createDocumentFragment();
      Array.from(p.childNodes).forEach(n=> frag.appendChild(n));
      p.replaceWith(frag);
    }
  });
  // Remove leading/trailing and duplicate <br>
  Array.from(container.querySelectorAll('br')).forEach(br=>{
    const parent = br.parentElement;
    if(!parent) return;
    const prev = br.previousSibling; const next = br.nextSibling;
    const prevIsBr = prev && prev.nodeType===1 && prev.nodeName==='BR';
    const nextIsBr = next && next.nodeType===1 && next.nodeName==='BR';
    const isFirst = !prev || (prev.nodeType===3 && !prev.nodeValue.trim());
    const isLast = !next || (next.nodeType===3 && !next.nodeValue.trim());
    if(prevIsBr || nextIsBr || isFirst || isLast){ br.remove(); }
  });
}
function convertTextOrHtmlToNodes(input, autoConvert){
  let html = String(input||'');
  if(autoConvert){
    const norm = html.replace(/\r\n?/g, '\n');
    const parts = norm.split(/\n{2,}/);
    const out = parts.map(part=>{
      const hasTag = hasAnyHtmlTag(part);
      const inner = (hasTag ? part : escapeHtml(part)).replace(/\n/g, '<br />');
      if(hasBlockTag(part)) return inner;
      return `<p>${inner}</p>`;
    }).join('\n');
    html = out;
  }
  const wrapper = document.createElement('div');
  wrapper.innerHTML = html;
  cleanupAutoConvertedHtml(wrapper);
  const frag = document.createDocumentFragment();
  Array.from(wrapper.childNodes).forEach(n=> frag.appendChild(n));
  return frag;
}
function convertTextOrHtmlToHtml(input, autoConvert){
  const frag = convertTextOrHtmlToNodes(input, autoConvert);
  const tmp = document.createElement('div');
  tmp.appendChild(frag);
  return tmp.innerHTML;
}

/* ===== Append external HTML before/after the chart ===== */
function showAppendHtmlPanel(show){ const p = byId('appendHtmlPanel'); if(p) p.style.display = show ? 'block' : 'none'; }
function sanitizeUserHtml(html){
  // strip <script> tags for safety
  try{
    const tmp = document.createElement('div');
    tmp.innerHTML = html || '';
    tmp.querySelectorAll('script').forEach(s=> s.remove());
    return tmp.innerHTML;
  }catch(_){ return html || ''; }
}
function applyAppendedHtmlToRenderArea(){
  const area = byId('renderArea'); if(!area) return;
  // Before-prologue block
  let before = area.querySelector(':scope > .inserted-html-before-prologue');
  if(globalState.beforeHtml){
    if(!before){ before = document.createElement('div'); before.className = 'inserted-html-before-prologue'; area.insertBefore(before, area.firstChild || null); }
    before.innerHTML = globalState.beforeHtml;
  } else if(before){ before.remove(); }

  // After-chart block: place after table, but before abbreviations if they are at bottom
  let after = area.querySelector(':scope > .inserted-html-after-chart');
  if(globalState.afterHtml){
    if(!after){ after = document.createElement('div'); after.className = 'inserted-html-after-chart'; }
    after.innerHTML = globalState.afterHtml;
    const tableWrap = area.querySelector('table.chartshell')?.closest('.chartshell-wrapper') || area.querySelector('table.chartshell');
    const abbrBlock = area.querySelector(':scope > .chart-abbrev-block');
    const abbrBottom = (globalState.abbrevPrefs && globalState.abbrevPrefs.include && globalState.abbrevPrefs.position === 'bottom');
    if(abbrBottom && abbrBlock){
      area.insertBefore(after, abbrBlock);
    } else if(tableWrap){
      if(tableWrap.nextSibling){ area.insertBefore(after, tableWrap.nextSibling); }
      else { area.appendChild(after); }
    } else {
      // fallback to end
      area.appendChild(after);
    }
  } else if(after){ after.remove(); }

  // Update small statuses
  const bstat = byId('beforeHtmlStatus'); if(bstat) bstat.textContent = globalState.beforeHtmlName ? `Attached: ${globalState.beforeHtmlName}` : '';
  const astat = byId('afterHtmlStatus'); if(astat) astat.textContent = globalState.afterHtmlName ? `Attached: ${globalState.afterHtmlName}` : '';
}
function initAppendHtmlControls(){
  const beforeIn = byId('beforeHtmlInput');
  const afterIn = byId('afterHtmlInput');
  const clearB = byId('clearBeforeHtmlBtn');
  const clearA = byId('clearAfterHtmlBtn');
  if(!beforeIn || !afterIn) return;
  const readFile = async (file)=>{ if(!file) return null; const txt = await file.text(); return sanitizeUserHtml(txt); };
  beforeIn.addEventListener('change', async e=>{
    const f = e.target.files && e.target.files[0];
    if(!f){ globalState.beforeHtml = null; globalState.beforeHtmlName=''; applyAppendedHtmlToRenderArea(); return; }
    globalState.beforeHtml = await readFile(f); globalState.beforeHtmlName = f.name || '';
    applyAppendedHtmlToRenderArea();
    // Re-insert prologue after the before block if needed
    applyPrologueToRenderArea(loadProloguePrefs());
    // Abbrev may need to shift down
    applyAbbrevToRenderArea(globalState.abbrevPrefs || loadAbbrevPrefs());
  });
  afterIn.addEventListener('change', async e=>{
    const f = e.target.files && e.target.files[0];
    if(!f){ globalState.afterHtml = null; globalState.afterHtmlName=''; applyAppendedHtmlToRenderArea(); return; }
    globalState.afterHtml = await readFile(f); globalState.afterHtmlName = f.name || '';
    applyAppendedHtmlToRenderArea();
  });
  clearB.addEventListener('click', ()=>{ globalState.beforeHtml=null; globalState.beforeHtmlName=''; beforeIn.value=''; applyAppendedHtmlToRenderArea(); applyPrologueToRenderArea(loadProloguePrefs()); applyAbbrevToRenderArea(globalState.abbrevPrefs || loadAbbrevPrefs()); });
  clearA.addEventListener('click', ()=>{ globalState.afterHtml=null; globalState.afterHtmlName=''; afterIn.value=''; applyAppendedHtmlToRenderArea(); });
}

/* ===== Main detection & dispatch ===== */
async function renderDocument(xmlDoc){
  // reset state
  globalState = { phonemeIndex:{}, idToNatclassIds:{}, natclassElements:{}, phonemeRowIds:{}, showNames: byId('showNames').checked };

  const root = xmlDoc.documentElement;
  const tag = root.nodeName.toLowerCase();
  const area = byId('renderArea');
  area.innerHTML = '';

  // Detect Text Chart (Discourse chart) and render via XSLT
  if(isTextChartDocument(xmlDoc)){
    const rendered = await renderTextChart(xmlDoc);
    area.innerHTML = '';
    showAppendHtmlPanel(true);
    // Initialize Append HTML controls once
    if(!byId('appendHtmlPanel').dataset.wired){ initAppendHtmlControls(); byId('appendHtmlPanel').dataset.wired = '1'; }
    // Apply any previously selected before-html prior to placing prologue
    applyAppendedHtmlToRenderArea();
    // Show prologue controls and inject current prologue before the chart
    showProloguePanel(true);
    // Wire collapsibles (collapsed by default; persisted)
    wireCollapsible('prologuePanel','prologueHeader');
    applyPrologueToRenderArea(loadProloguePrefs());
  // Show Postlogue controls (for export)
  showPostloguePanel(true);
  if(!byId('postloguePanel').dataset.wired){ initPostlogueControls(); byId('postloguePanel').dataset.wired = '1'; }
  wireCollapsible('postloguePanel','postlogueHeader');
    // Scan listRef abbreviations and show Abbrev controls
    globalState.chartAbbrevLabels = collectListRefLabelsFromXml(xmlDoc);
    showAbbrevPanel(true);
    wireCollapsible('abbrevPanel','abbrevHeader');
    buildAbbrevControls(globalState.chartAbbrevLabels);
    // Prepare ListRef controls (we will collect labels from rendered DOM; compute a suggested order from XML)
    const suggestedOrder = computeListRefSuggestedOrderFromXml(xmlDoc);
    showListRefPanel(true);
    wireCollapsible('listRefPanel','listRefHeader');
    if(rendered){
      area.appendChild(rendered);
      // Enable column resizing on the text chart table
      enableTextChartColumnResize(area);
      // Apply freeze headers if saved and show control
      const fhc = byId('freezeHeadersContainer'); if(fhc) fhc.style.display = 'flex';
      initFreezeHeadersControl();
      const savedFreeze = loadJSON(FREEZE_HEADERS_KEY); setTimeout(()=> setFreezeHeadersEnabled(!!(savedFreeze && savedFreeze.enabled)), 0);
      // Ensure abbreviations block is positioned correctly relative to chart
      applyAbbrevToRenderArea(globalState.abbrevPrefs || loadAbbrevPrefs());
      // Now insert after-chart HTML in final position
      applyAppendedHtmlToRenderArea();
      wireCollapsible('appendHtmlPanel','appendHeader');
      // Insert Epilogue live preview at end
      applyEpilogueToRenderArea(loadPostloguePrefs());
      // Collect ListRef labels from rendered DOM (data-listref set by XSL), build controls with suggested order, and apply prefs
      globalState.listRefLabels = collectListRefLabelsFromRendered(area);
      buildListRefControls(globalState.listRefLabels, suggestedOrder);
    }
    else { area.textContent = 'Failed to render Text Chart.'; }
    // Show print-headers toggle when a Text Chart is displayed
  const rhc = byId('repeatHeadersContainer');
  if(rhc) rhc.style.display = 'flex';
  // Ensure the checkbox reflects saved preference and style is applied
  initRepeatHeadersControl();
  // If thead exists, apply current saved setting right now
  const saved = loadJSON(PRINT_HEADERS_KEY);
  const enabled = !!(saved && saved.enabled);
  setPrintHeadersEnabled(enabled);
    return;
  }

  // Order of detection: Phonology, Translated Lists (AUni multi), Monolingual list, Wordforms, Generic
  if(tag === 'phonology'){
    showProloguePanel(false);
    showAbbrevPanel(false);
    area.appendChild(renderPhonologyView(xmlDoc));
    return;
  }

  if(tag === 'list' || tag === 'lists'){
    // detect AUni-based multilingual lists
    const aunis = xmlDoc.querySelectorAll('AUni[ws]');
    const langSet = new Set(Array.from(aunis).map(a => a.getAttribute('ws')));
    if(langSet.size > 1){
      showProloguePanel(false);
      showAbbrevPanel(false);
      area.appendChild(renderTranslatedListView(root, Array.from(langSet)));
      return;
    } else {
      showProloguePanel(false);
      showAbbrevPanel(false);
      area.appendChild(renderListView(root));
      return;
    }
  }

  // Wordforms detection (FieldWorks uses a <wordforms> root or similar)
  const wfNodes = xmlDoc.getElementsByTagName('wordforms');
  if(wfNodes && wfNodes.length > 0){
    showProloguePanel(false);
    showAbbrevPanel(false);
    area.appendChild(renderWordformsView(xmlDoc));
    return;
  }

  // fallback generic
  showProloguePanel(false);
  showAbbrevPanel(false);
  showAppendHtmlPanel(false);
  area.appendChild(renderGenericView(root));
  // Hide print-headers toggle for non-TextChart views
  const rhc = byId('repeatHeadersContainer');
  if(rhc) rhc.style.display = 'none';
  const fhc2 = byId('freezeHeadersContainer');
  if(fhc2) fhc2.style.display = 'none';
  setPrintHeadersEnabled(false);
  showListRefPanel(false);
  showPostloguePanel(false);
}

/* ===== Text Chart detection and rendering (XSLT) ===== */
function isTextChartDocument(xmlDoc){
  if(!xmlDoc || !xmlDoc.documentElement) return false;
  // Typical structure: <document><chart>...</chart></document> or a top-level <chart>
  return !!(xmlDoc.querySelector('document > chart > row') || xmlDoc.querySelector('chart > row'));
}

async function loadTextChartXSL(){
  const url = `textchart/textchart-to-html.xsl?v=${Date.now()}`;
  const resp = await fetch(url);
  if(!resp.ok) throw new Error(`Failed to fetch XSL (${resp.status})`);
  const txt = await resp.text();
  const doc = new DOMParser().parseFromString(txt, 'text/xml');
  const err = doc.getElementsByTagName('parsererror')[0];
  if(err) throw new Error('XSL parse error: ' + err.textContent.trim());
  return doc;
}

async function renderTextChart(xmlDoc){
  if(typeof XSLTProcessor === 'undefined'){
    const frag = document.createDocumentFragment();
    frag.appendChild(create('div', {cls:'small-muted'}, 'XSLTProcessor not supported in this browser.'));
    return frag;
  }
  const xslDoc = await loadTextChartXSL();
  const proc = new XSLTProcessor();
  proc.importStylesheet(xslDoc);
  try{
    // Optional: pass through debug param from URL (?debug=1)
    const urlParams = new URLSearchParams(window.location.search);
    const dbg = urlParams.get('debug');
    if(dbg && ['1','true','yes','on'].includes(dbg.toLowerCase())){
      proc.setParameter(null, 'debug', 'true');
    }
  }catch(_){/* no-op if params unsupported */}

  // Run transform to a fragment, then extract the body contents if present
  const frag = proc.transformToFragment(xmlDoc, document);
  const wrapper = document.createElement('div');
  wrapper.appendChild(frag);
  // If XSL produced a <head>, merge its styles into the page once
  const head = wrapper.querySelector('head');
  if (head) {
    // Inline <style>
    const styleEl = head.querySelector('style');
    if (styleEl) {
      const EXISTING_ID = 'textchart-xsl-style';
      let dest = document.getElementById(EXISTING_ID);
      if (!dest) {
        dest = document.createElement('style');
        dest.id = EXISTING_ID;
        document.head.appendChild(dest);
      }
      dest.textContent = styleEl.textContent || '';
    }
    // Linked stylesheets (if any in future)
    head.querySelectorAll('link[rel="stylesheet"][href]').forEach(link => {
      const href = link.getAttribute('href');
      if (!href) return;
      // Avoid duplicates by href
      const exists = Array.from(document.head.querySelectorAll('link[rel="stylesheet"][href]'))
        .some(l => l.getAttribute('href') === href);
      if (!exists) {
        const copy = document.createElement('link');
        copy.rel = 'stylesheet';
        copy.href = href;
        document.head.appendChild(copy);
      }
    });
  }
  const body = wrapper.querySelector('body');
  const outFrag = document.createDocumentFragment();
  const source = body || wrapper; // prefer body if the XSL produced a full HTML doc
  Array.from(source.childNodes).forEach(n => outFrag.appendChild(n));
  return outFrag;
}

/* ===== Monolingual List (unchanged behavior) ===== */
function renderListView(root) {
  // Accept either a single <list> or a top-level <lists> container
  if(!root) return create('div', {}, '(no list)');
  const nodeName = (root.nodeName || '').toLowerCase();
  if(nodeName === 'lists'){
    const outer = create('div');
    const lists = Array.from(root.querySelectorAll(':scope > list'));
    if(lists.length === 0) return outer;
    lists.forEach(l => outer.appendChild(renderListView(l)));
    return outer;
  }

  const container = create('div');
  // title: prefer Name or name inside the list; also accept a <name><str> pattern
  const title = (root.querySelector(':scope > name, :scope > Name')?.textContent?.trim()) || (root.querySelector(':scope > Name str, :scope > name str')?.textContent?.trim()) || 'List';
  container.appendChild(create('div', { cls: 'section-title' }, title));

  // helper to find direct "item-like" children (item, letitem, sditem)
  function itemChildrenOf(el){
    return Array.from(el.querySelectorAll(':scope > item, :scope > letitem, :scope > sditem'));
  }

  function buildItem(node) {
    const li = create('li');

    // collect children from direct item-like children and <subitems>
    const direct = itemChildrenOf(node);
    const subitemsContainer = node.querySelector(':scope > subitems');
    const sub = subitemsContainer ? itemChildrenOf(subitemsContainer) : [];
    const allChildren = direct.concat(sub);
    const hasChildren = allChildren.length > 0;

    // add toggle affordance (always present for consistent layout)
    const toggle = create('span', { cls: 'toggle' }, hasChildren ? '\u25be' : ' ');
    if(hasChildren) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    // display name (handle <name ws="..."> and <name><str ws=...> patterns)
    const nameNode = node.querySelector(':scope > name, :scope > Name');
    const rawName = nameNode ? nameNode.textContent.trim() : (node.getAttribute && node.getAttribute('name')) || node.nodeName;
    const abbrNode = node.querySelector(':scope > abbr, :scope > Abbreviation');
    const abbrText = abbrNode ? abbrNode.textContent.trim() : (node.getAttribute && (node.getAttribute('abbr') || node.getAttribute('ws'))) || '';
    const text = abbrText ? `${rawName} (${abbrText})` : rawName;
    li.appendChild(document.createTextNode(text));

    if (hasChildren) {
      const ul = create('ul', { cls: 'tree' });
      allChildren.forEach(ci => ul.appendChild(buildItem(ci)));
      li.appendChild(ul);

      toggle.addEventListener('click', () => {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '\u25be' ? '\u25b8' : '\u25be';
      });
    }

    return li;
  }

  // find top-level items: could be directly under list (item/letitem/sditem) or inside an <items> wrapper
  let topItems = itemChildrenOf(root);
  if(topItems.length === 0){
    const itemsWrapper = root.querySelector(':scope > items');
    if(itemsWrapper) topItems = itemChildrenOf(itemsWrapper);
  }

  const topUL = create('ul', { cls: 'tree' });
  topItems.forEach(it => topUL.appendChild(buildItem(it)));
  container.appendChild(topUL);

  return container;
}

/* ===== Translated (multilingual) List view + Language Controls ===== */
function renderTranslatedListView(root, langList){
  // canonicalize languages (stable order): prefer 'en' if present
  const langs = Array.from(langList);
  langs.sort((a,b)=>{
    if(a.toLowerCase().includes('en') && !b.toLowerCase().includes('en')) return -1;
    if(b.toLowerCase().includes('en') && !a.toLowerCase().includes('en')) return 1;
    return a.localeCompare(b);
  });

  // load saved prefs and merge defaults
  const saved = loadJSON(LANG_PREFS_KEY) || {};
  const prefs = {};
  langs.forEach((ws,i)=> {
    prefs[ws] = {
      ws,
      order: (saved[ws] && typeof saved[ws].order === 'number') ? saved[ws].order : i,
      visible: (saved[ws] && typeof saved[ws].visible === 'boolean') ? saved[ws].visible : true
    };
  });
  // compact orders
  const orderedLangs = Object.values(prefs).sort((a,b)=>a.order-b.order).map(l=>l.ws);
  orderedLangs.forEach((ws,i)=> prefs[ws].order = i);
  saveJSON(LANG_PREFS_KEY, prefs);

  const container = create('div');
  const title = root.querySelector(':scope > Name AUni[ws="en"], :scope > Name AUni, :scope > Name, :scope > name')?.textContent?.trim() || 'Translated List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  const controls = create('div', {cls:'lang-controls'});
  container.appendChild(controls);

  function buildLangControls(){
    controls.innerHTML = '';
    const arr = Object.values(prefs).sort((a,b)=>a.order-b.order);
    arr.forEach((L, idx)=>{
      const item = create('div', {cls:'lang-item'});
      item.style.display = 'flex'; item.style.alignItems = 'center'; item.style.gap = '6px';

      const codeSpan = create('span', {}, L.ws);
      codeSpan.style.fontWeight = '600';
      item.appendChild(codeSpan);

      const up = create('button', {cls:'icon-btn', title:'Move up (higher priority)'}, '⬆️');
      up.addEventListener('click', ()=> { swapOrder(L.ws, -1); });
      item.appendChild(up);

      const down = create('button', {cls:'icon-btn', title:'Move down (lower priority)'}, '⬇️');
      down.addEventListener('click', ()=> { swapOrder(L.ws, +1); });
      item.appendChild(down);

      const vis = create('button', {cls:'icon-btn', title: L.visible ? 'Hide language' : 'Show language'}, L.visible ? '👁️' : '🚫');
      vis.addEventListener('click', ()=> { prefs[L.ws].visible = !prefs[L.ws].visible; saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems(); });
      item.appendChild(vis);

      controls.appendChild(item);
    });

    const reset = create('button', {cls:'small-btn secondary', title:'Reset language order and visibility to defaults'}, 'Reset');
    reset.addEventListener('click', ()=> {
      langs.forEach((ws,i)=> { prefs[ws].order = i; prefs[ws].visible = true; });
      saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
    });
    controls.appendChild(reset);
  }

  const listContainer = create('div');
  container.appendChild(listContainer);

  function renderItems(){
    listContainer.innerHTML = '';
    const ordered = Object.values(prefs).sort((a,b)=>a.order-b.order).filter(l=>l.visible).map(l=>l.ws);
    if(ordered.length === 0){
      listContainer.appendChild(create('div', {cls:'small-muted'}, 'No languages selected. Use controls to show at least one language.'));
      return;
    }
    const poss = root.querySelector(':scope > Possibilities, :scope > possibilities') || root;
    const topItems = Array.from(poss.children).filter(c=>c.nodeType === 1);
    const topUL = create('ul', {cls:'tree'});
    topItems.forEach(ti => topUL.appendChild(buildItem(ti, ordered)));
    listContainer.appendChild(topUL);
  }

  function buildItem(node, visibleLangs){
    const li = create('li');
    const sub = node.querySelector(':scope > SubPossibilities, :scope > SubPossibility, :scope > Possibilities');
    const hasSub = sub && Array.from(sub.children).some(c=>c.nodeType === 1);
    const toggle = create('span', {cls:'toggle'}, hasSub ? '▾' : ' ');
    if(hasSub) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const nameNode = node.querySelector(':scope > Name, :scope > name');
    const abbrNode = node.querySelector(':scope > Abbreviation, :scope > abbr');
    const names = collectAUniMap(nameNode);
    const abbrs = collectAUniMap(abbrNode);
    const inline = create('span');
    inline.innerHTML = buildMultilingualInlineHTML(names, abbrs, visibleLangs);
    li.appendChild(inline);

    if(hasSub){
      const ul = create('ul', {cls:'tree'});
      Array.from(sub.children).filter(c=>c.nodeType===1).forEach(ch => ul.appendChild(buildItem(ch, visibleLangs)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
      });
    }
    return li;
  }

  function swapOrder(ws, delta){
    const entries = Object.values(prefs).sort((a,b)=>a.order-b.order);
    const idx = entries.findIndex(e => e.ws === ws);
    const target = idx + delta;
    if(target < 0 || target >= entries.length) return;
    const a = entries[idx], b = entries[target];
    const t = a.order; a.order = b.order; b.order = t;
    saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
  }

  buildLangControls();
  renderItems();
  return container;
}

/* ===== Helpers for multilingual lists ===== */
function collectAUniMap(node){
  if(!node) return [];
  const a = Array.from(node.querySelectorAll('AUni'));
  if(a.length) return a.map(x => ({ ws: x.getAttribute('ws') || '', text: x.textContent.trim() }));
  // fallback: Name with ws attribute (mono) or plain text
  if(node.hasAttribute && node.hasAttribute('ws')) return [{ ws: node.getAttribute('ws') || '', text: (node.textContent || '').trim() }];
  const txt = (node.textContent || '').trim();
  return txt ? [{ ws:'', text: txt }] : [];
}

function buildMultilingualInlineHTML(names, abbrs, visibleLangs){
  if(!names || names.length === 0) return '(unnamed)';
  const shown = visibleLangs.map(ws => names.find(n => n.ws === ws)).filter(Boolean);
  if(!shown.length) return '(none)';
  const main = shown[0];
  const others = shown.slice(1);
  let html = `<span class="translation-main">${escapeHtml(main.text)}</span>`;
  if(others.length) html += ' ' + others.map(o => `<span class="translation-others">${escapeHtml(o.text)}</span>`).join(' · ');
  if(abbrs && abbrs.length){
    const abv = visibleLangs.map(ws => (abbrs.find(a => a.ws === ws) || {}).text).filter(Boolean);
    if(abv.length) html += ` <span class="small-muted">[${abv.map(escapeHtml).join(' / ')}]</span>`;
  }
  return html;
}

/* ===== Generic recursive fallback (unchanged) ===== */
function renderGenericView(root){
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Generic XML View'));
  const rootUL = create('ul', {cls:'tree'});
  rootUL.appendChild(build(root));
  container.appendChild(rootUL);
  return container;

  function build(node){
    const li = create('li');
    const childElements = Array.from(node.childNodes).filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.nodeValue.trim()));
    const hasChildren = childElements.length > 0;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '▾' : ' ');
    if(hasChildren) toggle.style.cursor='pointer';
    li.appendChild(toggle);

    const labelText = node.nodeType === 1 ? node.nodeName : '';
    const labelSpan = create('span');
    if(globalState.showNames && node.nodeType === 1) labelSpan.textContent = labelText + ': ';
    if(globalState.showNames && node.nodeType === 1) labelSpan.style.fontWeight = '600';
    li.appendChild(labelSpan);

    if(node.nodeType === 3){
      li.appendChild(document.createTextNode(node.nodeValue.trim()));
    } else {
      const textChild = Array.from(node.childNodes).filter(n=>n.nodeType===3 && n.nodeValue.trim())[0];
      if(textChild && childElements.every(n => n.nodeType === 3 || (n.nodeType === 1 && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3))){
        li.appendChild(create('span', {}, textChild.nodeValue.trim()));
      } else {
        const subUL = create('ul', {cls:'tree'});
        childElements.forEach(ch => subUL.appendChild(build(ch)));
        li.appendChild(subUL);
        if(hasChildren){
          toggle.addEventListener('click', ()=> {
            li.classList.toggle('collapsed');
            toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
          });
        }
      }
    }
    if(node.nodeType === 1) li.setAttribute('data-gen-label', node.nodeName);
    return li;
  }
}

/* ===== Phonology rendering (human-friendly) ===== */
function renderPhonologyView(xmlDoc){
  const root = xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Phonology Summary'));
  container.appendChild(create('div', {cls:'small-muted'}, `Version ${root.getAttribute('Version') || '—'} — DefaultVernWs: ${root.getAttribute('DefaultVernWs') || '—'}`));

  // index phonemes
  globalState.phonemeIndex = {};
  const phonemes = Array.from(xmlDoc.getElementsByTagName('PhPhoneme') || []);
  phonemes.forEach(p => {
    const id = p.getAttribute('Id');
    const symbol = pickAUni(p.querySelector(':scope > Name')) || '';
    const desc = p.querySelector(':scope > Description Run')?.textContent?.trim() || '';
    const codes = Array.from(p.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a => a.textContent.trim()).filter(Boolean);
    globalState.phonemeIndex[id] = { id, symbol, desc, codes, node: p };
  });

  // phoneme sets / inventory
  const sets = Array.from(xmlDoc.getElementsByTagName('PhPhonemeSet') || []);
  sets.forEach(set => {
    const setName = pickAUni(set.querySelector(':scope > Name')) || 'Phoneme Set';
    const setDiv = create('div', {cls:'natclass'});
    setDiv.appendChild(create('div', {cls:'section-title'}, setName));
    const setDesc = set.querySelector(':scope > Description Run')?.textContent;
    if(setDesc) setDiv.appendChild(create('div', {cls:'small-muted'}, setDesc));

    const table = create('table', {cls:'phonemes'});
    table.innerHTML = '<thead><tr><th>Symbol</th><th>Description</th><th>ID</th><th>Codes</th></tr></thead>';
    const tbody = create('tbody');
    const rows = Array.from(set.querySelectorAll(':scope > Phonemes PhPhoneme')) || phonemes;
    rows.forEach(pnode => {
      const pid = pnode.getAttribute('Id');
      const data = globalState.phonemeIndex[pid] || {
        id: pid,
        symbol: pickAUni(pnode.querySelector(':scope > Name')) || '',
        desc: pnode.querySelector(':scope > Description Run')?.textContent || '',
        codes: Array.from(pnode.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim())
      };
      const row = create('tr', {id: 'phoneme-row-' + data.id});
      const symbolCell = create('td');
      const symBtn = create('span', {cls:'symbol-pill'}, data.symbol || '(no symbol)');
      symBtn.style.cursor = 'pointer';
      symBtn.addEventListener('click', ()=> onPhonemeSymbolClick(data.id));
      symbolCell.appendChild(symBtn);
      row.appendChild(symbolCell);
      row.appendChild(create('td', {}, data.desc || ''));
      row.appendChild(create('td', {}, data.id));
      row.appendChild(create('td', {}, (data.codes && data.codes.join(', ')) || ''));
      tbody.appendChild(row);
      globalState.phonemeRowIds[data.id] = row.id;
    });
    table.appendChild(tbody);
    setDiv.appendChild(table);

    // boundary markers
    const bMarkers = Array.from(set.querySelectorAll(':scope > BoundaryMarkers PhBdryMarker')) || [];
    if(bMarkers.length){
      setDiv.appendChild(create('div', {cls:'section-title'}, 'Boundary Markers'));
      const bmList = create('div', {cls:'small-muted'});
      bMarkers.forEach(bm => {
        const bmName = pickAUni(bm.querySelector(':scope > Name')) || bm.getAttribute('Id') || '';
        const bmCodes = Array.from(bm.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim()).filter(Boolean);
        bmList.appendChild(create('div', {}, `${bmName} ${ bmCodes.length ? '(' + bmCodes.join(', ') + ')' : ''}`));
      });
      setDiv.appendChild(bmList);
    }

    container.appendChild(setDiv);
  });

  // natural classes
  const ncs = Array.from(xmlDoc.getElementsByTagName('PhNCSegments') || []);
  if(ncs.length){
    container.appendChild(create('div', {cls:'section-title'}, 'Natural Classes'));
    ncs.forEach((nc, idx) => {
      const ncId = nc.getAttribute('Id') || ('nc-' + idx);
      const name = pickAUni(nc.querySelector(':scope > Name')) || nc.getAttribute('Id') || 'Unnamed';
      const abbr = pickAUni(nc.querySelector(':scope > Abbreviation')) || '';
      const desc = nc.querySelector(':scope > Description Run')?.textContent || '';
      const ncEl = create('div', {cls:'natclass', id: 'natclass-' + ncId});
      const title = create('div', {cls:'section-title'}, name + (abbr ? (' (' + abbr + ')') : ''));
      ncEl.appendChild(title);
      if(desc) ncEl.appendChild(create('div', {cls:'small-muted'}, desc));
      const segments = Array.from(nc.querySelectorAll(':scope > Segments')).map(s => s.getAttribute('dst')).filter(Boolean);
      const membersDiv = create('div', {cls:'members'});
      segments.forEach(sid => {
        const phon = globalState.phonemeIndex[sid];
        const text = phon ? (phon.symbol || phon.id) : sid;
        const pill = create('span', {cls:'symbol-pill'}, text);
        pill.addEventListener('click', ()=> {
          if(globalState.phonemeRowIds[sid]) scrollToAndHighlight(globalState.phonemeRowIds[sid]);
          else alert('Phoneme ID ' + sid + ' not found in phoneme index.');
        });
        membersDiv.appendChild(pill);
        if(!globalState.idToNatclassIds[sid]) globalState.idToNatclassIds[sid] = [];
        globalState.idToNatclassIds[sid].push(ncEl.id);
      });
      ncEl.appendChild(membersDiv);
      container.appendChild(ncEl);
      globalState.natclassElements[ncEl.id] = ncEl;
    });
  }

  // simple placeholders for Environments, Contexts, Rules
  const envs = Array.from(xmlDoc.getElementsByTagName('Environments') || []);
  envs.forEach(en => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Environments'));
    sec.appendChild(en.hasChildNodes() ? renderGenericView(en) : create('div', {cls:'small-muted'}, '(no environment definitions)'));
    container.appendChild(sec);
  });
  const ctxs = Array.from(xmlDoc.getElementsByTagName('Contexts') || []);
  ctxs.forEach(c => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Contexts'));
    sec.appendChild(c.hasChildNodes() ? renderGenericView(c) : create('div', {cls:'small-muted'}, '(no contexts defined)'));
    container.appendChild(sec);
  });

  // interactive behavior: clicking phoneme rows highlights natural classes
  Object.keys(globalState.phonemeRowIds).forEach(pid => {
    const rid = globalState.phonemeRowIds[pid];
    const row = document.getElementById(rid);
    if(row){
      row.addEventListener('click', ()=> {
        const natIds = globalState.idToNatclassIds[pid] || [];
        Object.values(globalState.natclassElements).forEach(el=> el.style.boxShadow = '');
        if(natIds.length){
          natIds.forEach(nid => {
            const el = globalState.natclassElements[nid];
            if(el){
              el.style.boxShadow = '0 0 0 3px rgba(11,110,219,0.08)';
              el.scrollIntoView({behavior:'smooth', block:'center'});
            }
          });
        } else {
          row.classList.add('highlight');
          setTimeout(()=> row.classList.remove('highlight'), 1200);
        }
      });
    }
  });

  return container;
}

/* ===== Wordforms export rendering (Card + Table + gloss language controls) ===== */
function renderWordformsView(xmlDoc){
  // root might be <wordforms> or something similar depending on export
  const root = xmlDoc.getElementsByTagName('wordforms')[0] || xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Wordforms'));

  // collect all wordform nodes
  // FieldWorks samples may use <wordform> children
  const wfNodes = Array.from(root.getElementsByTagName('wordform'));
  // fallback: maybe root contains <Wordform> nodes
  if(wfNodes.length === 0){
    const alt = Array.from(root.getElementsByTagName('WordForm')).concat(Array.from(root.getElementsByTagName('Wordform')));
    if(alt.length) wfNodes.push(...alt);
  }

  // scan for gloss languages across all gloss elements
  const glossElems = Array.from(xmlDoc.querySelectorAll('gloss[ws], gloss AUni[ws], glosses gloss[ws]')) // flexible
    .concat(Array.from(xmlDoc.querySelectorAll('gloss'))); // fallback
  const glossLangsSet = new Set();
  glossElems.forEach(g => {
    if(g.getAttribute && g.getAttribute('ws')) glossLangsSet.add(g.getAttribute('ws'));
    else {
      // also accept <gloss><AUni ws="..."> or similar
      const auni = g.querySelector && g.querySelector('AUni[ws]');
      if(auni) glossLangsSet.add(auni.getAttribute('ws'));
    }
  });
  const glossLangs = Array.from(glossLangsSet);
  glossLangs.sort((a,b)=> a.toLowerCase().includes('en')? -1 : a.localeCompare(b));

  // load wordform prefs (view mode + gloss languages visibility)
  const saved = loadJSON(WORDFORM_PREFS_KEY) || {};
  let viewMode = saved.viewMode || 'card'; // 'card' or 'table'
  let glossPrefs = saved.glossPrefs || {};
  // init prefs from discovered glossLangs
  glossLangs.forEach((ws,i) => {
    if(typeof glossPrefs[ws] !== 'object') glossPrefs[ws] = { ws, visible: true, order: i };
  });

  // UI controls
  const controls = create('div', {cls:'controls-inline'});
  const viewToggle = create('button', {cls:'small-btn', title:'Toggle Card/Table view'}, viewMode === 'card' ? 'Switch to Table View 📋' : 'Switch to Card View 🗂️');
  controls.appendChild(viewToggle);

  // gloss language chooser (only shown in Table view)
  const glossChooser = create('div', {cls:'small-muted'});
  glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
  glossChooser.style.paddingLeft = '8px';
  glossChooser.style.marginLeft = '8px';
  glossChooser.textContent = 'Gloss languages: ';
  glossLangs.forEach(ws => {
    const label = create('label');
    label.style.marginRight = '8px';
    const cb = create('input'); cb.type = 'checkbox'; cb.checked = glossPrefs[ws].visible; cb.dataset.ws = ws;
    cb.addEventListener('change', () => {
      glossPrefs[ws].visible = cb.checked; saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); renderItems();
    });
    label.appendChild(cb);
    label.appendChild(document.createTextNode(' ' + ws));
    glossChooser.appendChild(label);
  });

  controls.appendChild(glossChooser);
  container.appendChild(controls);

  // search/filter input (helpful)
  const searchRow = create('div', {cls:'small-muted'});
  searchRow.style.marginTop = '8px';
  searchRow.innerHTML = 'Filter: <input id="wf_search" placeholder="search form or gloss..." style="padding:4px;border-radius:4px;border:1px solid #ddd;margin-left:6px;">';
  container.appendChild(searchRow);

  const listArea = create('div');
  listArea.style.marginTop = '8px';
  container.appendChild(listArea);

  // wire view toggle
  viewToggle.addEventListener('click', ()=>{
    viewMode = viewMode === 'card' ? 'table' : 'card';
    saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs });
    viewToggle.textContent = viewMode === 'card' ? 'Switch to Table View 📋' : 'Switch to Card View 🗂️';
    glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
    renderItems();
  });

  // render items either card or table
  function renderItems(){
    listArea.innerHTML = '';
    const q = (byId('wf_search')?.value || '').trim().toLowerCase();

    // helper to collect form text, glosses, category, counts
    function extractData(wf){
      const forms = [];
      // FieldWorks uses <form ws="..."> inside wordform — but samples vary. We'll be flexible.
      const formNodes = Array.from(wf.querySelectorAll('form, Form, word'));
      if(formNodes.length === 0){
        // try direct text
        const txt = (wf.textContent || '').trim();
        if(txt) forms.push({ws:'', text: txt});
      } else {
        formNodes.forEach(fn => {
          // look for AUni children if present
          const aunis = fn.querySelectorAll && fn.querySelectorAll('AUni');
          if(aunis && aunis.length){
            aunis.forEach(a => forms.push({ ws: a.getAttribute('ws') || '', text: (a.textContent||'').trim() }));
          } else {
            const ws = fn.getAttribute && fn.getAttribute('ws') || '';
            const t = (fn.textContent || '').trim();
            if(t) forms.push({ ws, text: t });
          }
        });
      }

      // analyses -> gloss, category, counts
      const analyses = Array.from(wf.querySelectorAll('analysis, Analysis'));
      const glosses = []; // array of {ws,text}
      const categories = [];
      analyses.forEach(a => {
        const gNodes = Array.from(a.querySelectorAll('gloss, Gloss'));
        if(gNodes.length){
          gNodes.forEach(gn => {
            const aun = gn.querySelector && gn.querySelector('AUni[ws]');
            if(aun) glosses.push({ ws: aun.getAttribute('ws') || '', text: (aun.textContent||'').trim() });
            else {
              const ws = gn.getAttribute && gn.getAttribute('ws') || '';
              const t = (gn.textContent || '').trim();
              if(t) glosses.push({ ws, text: t });
            }
          });
        }
        const cat = a.querySelector('category, Category')?.textContent?.trim();
        if(cat) categories.push(cat);
      });

      // counts
      const predicted = parseInt(wf.getAttribute('PredictedAnalyses') || wf.getAttribute('predictedanalyses') || wf.querySelector('PredictedAnalyses')?.textContent || '0') || 0;
      const user = parseInt(wf.getAttribute('UserAnalyses') || wf.getAttribute('useranalyses') || wf.querySelector('UserAnalyses')?.textContent || '0') || 0;

      return { forms, glosses, categories, predicted, user, node: wf };
    }

    const dataList = wfNodes.map(wf => extractData(wf));

    // apply search filter: matches form text or any gloss text
    const filtered = dataList.filter(d => {
      if(!q) return true;
      const formMatch = d.forms.some(f => (f.text||'').toLowerCase().includes(q));
      const glossMatch = d.glosses.some(g => (g.text||'').toLowerCase().includes(q));
      const catMatch = d.categories.some(c => (c||'').toLowerCase().includes(q));
      return formMatch || glossMatch || catMatch;
    });

    if(viewMode === 'card'){
      // Card view
      filtered.forEach(d => {
        const card = create('div', {cls:'wordform-card'});
        const header = create('div', {cls:'wordform-header'});
        const main = create('div');
        const primaryForm = d.forms[0]?.text || '(no form)';
        main.appendChild(create('div', {cls:'wordform-main'}, primaryForm));
        main.appendChild(create('div', {cls:'wordform-meta'}, `Predicted: ${d.predicted} · User: ${d.user}`));
        header.appendChild(main);
        // small expand button (collapse/expand body)
        const expBtn = create('button', {cls:'small-btn', title:'Toggle details'}, '▾');
        header.appendChild(expBtn);
        card.appendChild(header);

        const body = create('div', {cls:'wordform-body'});
        if(d.glosses.length === 0 && d.categories.length === 0){
          body.appendChild(create('div', {cls:'small-muted'}, '— No analysis —'));
        } else {
          // group glosses by ws
          const byWs = {};
          d.glosses.forEach(g => { if(!byWs[g.ws]) byWs[g.ws] = []; byWs[g.ws].push(g.text); });
          Object.keys(byWs).forEach(ws => {
            const line = create('div');
            line.innerHTML = `<strong>Gloss (${escapeHtml(ws)}):</strong> ${escapeHtml(byWs[ws].join('; '))}`;
            body.appendChild(line);
          });
          if(d.categories.length){
            body.appendChild(create('div', {}, `Category: ${escapeHtml(d.categories.join('; '))}`));
          }
        }
        body.style.display = 'block';
        expBtn.addEventListener('click', ()=> {
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
          expBtn.textContent = expBtn.textContent === '▾' ? '▸' : '▾';
        });
        card.appendChild(body);
        listArea.appendChild(card);
      });
    } else {
      // Table view: show selected gloss columns based on glossPrefs
      const visibleGlossLangs = glossLangs.filter(ws => glossPrefs[ws] && glossPrefs[ws].visible);
      const table = create('table', {cls:'table-view'});
      // build header
      const thead = create('thead');
      const headerRow = create('tr');
      headerRow.appendChild(create('th', {}, 'Wordform'));
      visibleGlossLangs.forEach(ws => headerRow.appendChild(create('th', {}, `Gloss (${ws})`)));
      headerRow.appendChild(create('th', {}, 'Category'));
      headerRow.appendChild(create('th', {}, 'Pred'));
      headerRow.appendChild(create('th', {}, 'User'));
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = create('tbody');
      filtered.forEach(d => {
        const tr = create('tr');
        const primaryForm = d.forms[0]?.text || '(no form)';
        tr.appendChild(create('td', {}, primaryForm));
        visibleGlossLangs.forEach(ws => {
          const text = d.glosses.filter(g=>g.ws === ws).map(g=>g.text).join('; ') || '—';
          tr.appendChild(create('td', {}, text));
        });
        tr.appendChild(create('td', {}, d.categories.join('; ') || '—'));
        tr.appendChild(create('td', {}, String(d.predicted)));
        tr.appendChild(create('td', {}, String(d.user)));
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      listArea.appendChild(table);
    }
  }

  // initial render
  renderItems();

  // wire search input
  const searchInput = byId('wf_search');
  if(searchInput){
    searchInput.addEventListener('input', () => { renderItems(); });
  }

  // wire gloss chooser UI to persist prefs
  // already wired by checkboxes earlier when created, but ensure persistence for viewMode state
  // save viewMode & glossPrefs whenever changed
  function persistWordformPrefs(){ saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); }
  // update glossPrefs reference to the variable used by event handlers above
  // ensure glossPrefs is synced with UI checkbox states if user toggles view toggle
  // done through event handlers above that call saveJSON directly.

  return container;
}

/* ===== Utilities used by phonology rendering ===== */
function pickAUni(node){
  if(!node) return '';
  const aunis = Array.from(node.querySelectorAll('AUni'));
  if(aunis.length === 0) {
    const t = node.textContent && node.textContent.trim();
    return t || '';
  }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('fau')) return a.textContent.trim(); }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('en')) return a.textContent.trim(); }
  return aunis[0].textContent.trim();
}

/* ===== Click helpers ===== */
function onPhonemeSymbolClick(phonId){
  const rowId = globalState.phonemeRowIds[phonId];
  if(!rowId){ alert('Phoneme entry not found: ' + phonId); return; }
  scrollToAndHighlight(rowId);
}
function scrollToAndHighlight(rowId){
  const el = document.getElementById(rowId);
  if(!el) return;
  document.querySelectorAll('tr.highlight').forEach(r=> r.classList.remove('highlight'));
  el.classList.add('highlight');
  el.scrollIntoView({behavior:'smooth', block:'center'});
  el.classList.add('scroll-target');
  setTimeout(()=> el.classList.remove('scroll-target'), 2200);
}

/* ===== Build standalone HTML (for open/save) — note escaped closing tag to avoid template literal issues ===== */
function buildStandaloneHTML(){
  const render = byId('renderArea');
  // Gather prologue (if any) + current render content (without duplicating prologue)
  let content = '';
  const prologueNode = render.querySelector(':scope > .chart-prologue');
  const clone = render.cloneNode(true);
  // Helper: ensure destination table has individual <col> elements (no span)
  function ensureIndividualCols(tbl){
    const groups = Array.from(tbl.querySelectorAll('colgroup'));
    groups.forEach(g=>{
      const c = g.querySelector('col');
      if(!c) return;
      const span = Number(c.getAttribute('span')||'1');
      if(span > 1){
        c.removeAttribute('span');
        const frag = document.createDocumentFragment();
        for(let i=0;i<span;i++) frag.appendChild(document.createElement('col'));
        g.replaceChild(frag, c);
      }
    });
  }
  // Helper: freeze current column widths from live table into the cloned table
  function freezeChartColumnWidthsInClone(sourceRoot, cloneRoot){
    const srcTbl = sourceRoot.querySelector('table.chartshell');
    const dstTbl = cloneRoot.querySelector('table.chartshell');
    if(!srcTbl || !dstTbl) return;
    // Make sure destination has one <col> per column
    ensureIndividualCols(dstTbl);
    const dstCols = Array.from(dstTbl.querySelectorAll('col'));
    if(!dstCols.length) return;
    // Build widths array by measuring header (prefer title2), then fill from body rows as needed
    const widths = new Array(dstCols.length).fill(0);
    const srcHeader = srcTbl.querySelector('tr.row.title2') || srcTbl.querySelector('tr.row.title1');
    let colIndex = 0;
    if(srcHeader){
      srcHeader.querySelectorAll('th.cell').forEach(th=>{
        const span = Number(th.getAttribute('colspan')||'1');
        const w = Math.max(0, Math.round(th.getBoundingClientRect().width));
        const per = Math.max(0, Math.floor(w / span));
        for(let i=0;i<span && (colIndex + i) < widths.length;i++){
          widths[colIndex + i] = per;
        }
        colIndex += span;
      });
    }
    const srcBodyRows = Array.from(srcTbl.querySelectorAll('tbody tr'));
    function fillFromRow(row){
      let idx = 0;
      Array.from(row.children).forEach(td=>{
        const span = Number(td.getAttribute('colspan')||'1');
        const w = Math.max(0, Math.round(td.getBoundingClientRect().width));
        const per = Math.max(0, Math.floor(w / span));
        for(let i=0;i<span && (idx + i) < widths.length;i++){
          if(widths[idx + i] === 0) widths[idx + i] = per;
        }
        idx += span;
      });
    }
    if(widths.some(v=>v===0) && srcBodyRows.length){
      for(let r=0; r<Math.min(10, srcBodyRows.length); r++){
        fillFromRow(srcBodyRows[r]);
        if(!widths.some(v=>v===0)) break;
      }
    }
    // Apply a floor and assign to destination <col> style.width
    for(let i=0;i<widths.length;i++){
      const px = Math.max(40, widths[i] || 0);
      if(dstCols[i]) dstCols[i].style.width = px + 'px';
    }
    // Enforce fixed layout so widths render consistently in the export
    dstTbl.style.tableLayout = 'fixed';
    dstTbl.style.width = 'auto';
    dstTbl.style.maxWidth = '100%';
  }
  // Freeze widths before stripping interactive bits
  try{ freezeChartColumnWidthsInClone(render, clone); }catch(_){ /* non-fatal */ }
  // Keep column resizers in export so users can continue adjusting widths
  // Ensure destination table is marked as resizable for any styling hooks (optional)
  const dstTblForFlag = clone.querySelector('table.chartshell');
  if (dstTblForFlag) dstTblForFlag.setAttribute('data-resizable', '1');
  if(prologueNode){
    content += prologueNode.outerHTML; // put prologue first
    const cPrologue = clone.querySelector(':scope > .chart-prologue');
    if(cPrologue) cPrologue.remove(); // remove from rest of content
  }
  content += clone.innerHTML;

  // Epilogue content (appears after everything else in export)
  try{
    const postPrefs = loadJSON(TEXTCHART_POSTLOGUE_KEY) || {};
    const postHtml = postPrefs.html || '';
    const auto = typeof postPrefs.autoConvert === 'boolean' ? postPrefs.autoConvert : true;
    if(postHtml && postHtml.trim()){
      const converted = convertTextOrHtmlToHtml(postHtml, !!auto);
      content += `\n<div class="chart-epilogue">${converted}</div>`;
    }
  }catch(_){/* ignore */}

  // Pick a title for the export: prefer H1 from prologue, then any heading/div/p, else fallback
  let exportTitle = 'FLEx XML View Export';
  if (prologueNode) {
    const h1 = prologueNode.querySelector('h1');
    const anyHead = prologueNode.querySelector('h1,h2,h3,h4,h5,h6,div,p');
    const titleNode = h1 || anyHead;
    if (titleNode && titleNode.textContent) {
      const t = titleNode.textContent.replace(/\s+/g, ' ').trim();
      if (t) exportTitle = t;
    }
  }
  // Collect all current styles from <head> including any injected at runtime
  function collectCurrentHeadCSS(){
    let css = '';
    // Inline <style> tags in order
    document.head.querySelectorAll('style').forEach((s, idx)=>{
      const label = s.id ? `style#${s.id}` : `style[${idx}]`;
      css += `\n/* ${label} */\n` + (s.textContent || '') + '\n';
    });
    // Attempt to inline same-origin linked stylesheets
    Array.from(document.styleSheets || []).forEach(ss => {
      try{
        // Only include sheets originating from a <link> node we can read
        if(ss && ss.ownerNode && ss.ownerNode.tagName === 'LINK' && ss.cssRules){
          css += `\n/* linked stylesheet: ${ss.href || ''} */\n`;
          for(const rule of ss.cssRules){ css += rule.cssText + '\n'; }
        }
      }catch(e){ /* likely a cross-origin stylesheet; skip */ }
    });
    return css.trim();
  }
  const headCSS = collectCurrentHeadCSS();
  const savedFreeze = loadJSON(FREEZE_HEADERS_KEY);
  const freezeEnabled = !!(savedFreeze && savedFreeze.enabled);
  // Add minimal sticky header CSS to ensure freeze works even if outer CSS is pruned
  const stickyCSS = `
  .chartshell.freeze-headers thead tr.row.title1 th,
  .chartshell.freeze-headers thead tr.row.title2 th{position:sticky;z-index:3;background:#fff}
  .chartshell.freeze-headers thead tr.row.title1 th{top:var(--tc-sticky-top-1,0px)}
  .chartshell.freeze-headers thead tr.row.title2 th{top:var(--tc-sticky-top-2,32px);z-index:4}
  .chartshell-sticky-spacer{height:var(--tc-sticky-spacer,0px)}
  `;
  const doc = `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${escapeHtml(exportTitle)}</title>
${freezeEnabled ? '<meta name="flex-freeze-headers" content="1" />' : ''}
<style>${headCSS}\n${stickyCSS}</style>
</head>
<body>
${content}
<script>
  // Persisted freeze headers behavior from source document
  (function(){
    function computeStickyOffsets(){
      const tbl = document.querySelector('table.chartshell');
      if(!tbl) return;
      const head = tbl.querySelector('thead');
      const r1 = head?.querySelector('tr.row.title1');
      const r2 = head?.querySelector('tr.row.title2');
      const rect1 = r1?.getBoundingClientRect();
      const rect2 = r2?.getBoundingClientRect();
      const topBase = 0;
      const h1 = rect1 ? Math.ceil(rect1.height) : 0;
      const h2 = rect2 ? Math.ceil(rect2.height) : 0;
      document.documentElement.style.setProperty('--tc-sticky-top-1', topBase + 'px');
      document.documentElement.style.setProperty('--tc-sticky-top-2', (topBase + h1) + 'px');
      document.documentElement.style.setProperty('--tc-sticky-spacer', (h1 + h2) + 'px');
    }
    function applyFreezeHeaders(){
      const tbl = document.querySelector('table.chartshell');
      if(!tbl) return;
      tbl.classList.add('freeze-headers');
      const wrapper = tbl.closest('.chartshell-wrapper') || tbl.parentElement;
      let spacer = wrapper?.querySelector(':scope > .chartshell-sticky-spacer');
      if(!spacer){ spacer = document.createElement('div'); spacer.className = 'chartshell-sticky-spacer'; if(wrapper) wrapper.insertBefore(spacer, tbl); else tbl.parentElement?.insertBefore(spacer, tbl); }
      computeStickyOffsets();
      window.addEventListener('resize', computeStickyOffsets);
    }
    // Read preference from embedded data attribute if present
    const root = document.documentElement;
    const shouldFreeze = (function(){
      try{
        const meta = document.querySelector('meta[name="flex-freeze-headers"]');
        return meta && meta.getAttribute('content') === '1';
      }catch(_){ return false; }
    })();
    if(shouldFreeze){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', applyFreezeHeaders); else applyFreezeHeaders(); }
  })();
  document.querySelectorAll('.toggle').forEach(t=> {
    const parent = t.parentElement;
    t.addEventListener('click', ()=> {
      parent.classList.toggle('collapsed');
      t.textContent = t.textContent === '▾' ? '▸' : '▾';
    });
  });
  document.querySelectorAll('.symbol-pill').forEach(p=> {
    p.addEventListener('click', ()=> {
      const txt = p.textContent.trim();
      const rows = document.querySelectorAll('table.phonemes tbody tr');
      for(const r of rows){
        if(r.cells[0] && r.cells[0].textContent.trim() === txt){
          r.scrollIntoView({behavior:'smooth', block:'center'});
          r.classList.add('highlight');
          setTimeout(()=> r.classList.remove('highlight'), 1800);
          return;
        }
      }
    });
  });
  // Re-enable column resizing for Text Chart in exported document
  (function(){
    function wireHandleDrag(handle, allCols){
      let startX = 0, startWidth = 0, colEl = null;
      function computeMinColWidth(tbl, idx){
        let minW = 40;
        const rows = Array.from(tbl.querySelectorAll('tbody tr')).slice(0, 200);
        rows.forEach(row=>{
          let ci = 0; let cell = null;
          Array.from(row.children).some(td=>{
            const sp = Number(td.getAttribute('colspan')||'1');
            const covers = (idx >= ci) && (idx < ci + sp);
            ci += sp; if(covers){ cell = td; return true; } return false;
          });
          if(cell){
            let pairs = cell.querySelectorAll('.interlinear .pair:not(.note)');
            if(!pairs.length) pairs = cell.querySelectorAll('.interlinear .pair');
            pairs.forEach(p=>{ const w = Math.ceil(p.getBoundingClientRect().width); if(w > minW) minW = w; });
          }
        });
        return Math.max(40, minW);
      }
      function onMove(e){
        const dx = e.clientX - startX;
        const tbl = handle.closest('table');
        const idx = Number(handle.dataset.colEnd||'0');
        const minAllowed = computeMinColWidth(tbl, idx);
        const newW = Math.max(minAllowed, startWidth + dx);
        colEl.style.width = newW + 'px';
        handle.classList.add('dragging');
      }
      function onUp(){
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        handle.classList.remove('dragging');
      }
      handle.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        const idx = Number(handle.dataset.colEnd||'0');
        colEl = allCols[idx];
        if(!colEl) return;
        const tbl = handle.closest('table');
        const bodyRow = tbl.querySelector('tbody tr');
        let probeCell = null;
        if(bodyRow){
          let ci = 0; probeCell = Array.from(bodyRow.children).find(td=>{
            const sp = Number(td.getAttribute('colspan')||'1');
            const covers = (idx >= ci) && (idx < ci + sp);
            ci += sp; return covers;
          });
        }
        const rect = (probeCell || handle.parentElement).getBoundingClientRect();
        if(!colEl.style.width){ colEl.style.width = Math.max(40, Math.round(rect.width)) + 'px'; }
        startX = e.clientX;
        startWidth = parseFloat(colEl.style.width) || Math.max(40, Math.round(rect.width));
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
    function initExportResizing(){
      const tbl = document.querySelector('table.chartshell');
      if(!tbl) return;
      // Ensure fixed layout and individual cols
      tbl.style.tableLayout = 'fixed';
      tbl.style.width = 'auto';
      tbl.style.maxWidth = '100%';
      const groups = Array.from(tbl.querySelectorAll('colgroup'));
      const allCols = groups.flatMap(g => Array.from(g.querySelectorAll('col')));
      // Re-wire existing handles
      tbl.querySelectorAll('.col-resizer').forEach(h => wireHandleDrag(h, allCols));
      tbl.setAttribute('data-resizable', '1');
    }
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initExportResizing);
    else initExportResizing();
  })();
<\/script>
</body>
</html>`;
  return doc;
}

/* ===== Column resizing for Text Chart in-app ===== */
function expandColgroupsToIndividualCols(tbl){
  const groups = Array.from(tbl.querySelectorAll('colgroup'));
  groups.forEach(g=>{
    const c = g.querySelector('col');
    if(!c) return;
    const span = Number(c.getAttribute('span')||'1');
    if(span > 1){
      c.removeAttribute('span');
      const frag = document.createDocumentFragment();
      for(let i=0;i<span;i++) frag.appendChild(document.createElement('col'));
      g.replaceChild(frag, c);
    }
  });
}
function addResizeHandles(tbl){
  const header2 = tbl.querySelector('tr.row.title2');
  const header = header2 || tbl.querySelector('tr.row.title1');
  if(!header) return;
  let colIndex = 0;
  const groups = Array.from(tbl.querySelectorAll('colgroup'));
  const allCols = groups.flatMap(g => Array.from(g.querySelectorAll('col')));
  header.querySelectorAll('th.cell').forEach(th=>{
    const span = Number(th.getAttribute('colspan')||'1');
    const targetColEnd = colIndex + span - 1;
    const handle = document.createElement('div');
    handle.className = 'col-resizer';
    handle.title = 'Drag to resize column';
    handle.dataset.colEnd = String(targetColEnd);
    th.appendChild(handle);
    wireHandleDrag(handle, allCols);
    colIndex += span;
  });
}
function wireHandleDrag(handle, allCols){
  let startX = 0, startWidth = 0, colEl = null;
    function computeMinColWidth(tbl, idx){
      let minW = 40;
      const rows = Array.from(tbl.querySelectorAll('tbody tr')).slice(0, 200);
      rows.forEach(row=>{
        let ci = 0; let cell = null;
        Array.from(row.children).some(td=>{
          const sp = Number(td.getAttribute('colspan')||'1');
          const covers = (idx >= ci) && (idx < ci + sp);
          ci += sp; if(covers){ cell = td; return true; } return false;
        });
        if(cell){
          let pairs = cell.querySelectorAll('.interlinear .pair:not(.note)');
          if(!pairs.length) pairs = cell.querySelectorAll('.interlinear .pair');
          pairs.forEach(p=>{ const w = Math.ceil(p.getBoundingClientRect().width); if(w > minW) minW = w; });
        }
      });
      return Math.max(40, minW);
    }
  function onMove(e){
    const dx = e.clientX - startX;
      const tbl = handle.closest('table');
      const idx = Number(handle.dataset.colEnd||'0');
      const minAllowed = computeMinColWidth(tbl, idx);
      const newW = Math.max(minAllowed, startWidth + dx);
    colEl.style.width = newW + 'px';
    handle.classList.add('dragging');
  }
  function onUp(){
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    handle.classList.remove('dragging');
  }
  handle.addEventListener('mousedown', (e)=>{
    e.preventDefault();
    const idx = Number(handle.dataset.colEnd||'0');
    colEl = allCols[idx];
    if(!colEl) return;
    const tbl = handle.closest('table');
    const bodyRow = tbl.querySelector('tbody tr');
    let probeCell = null;
    if(bodyRow){
      let ci = 0; probeCell = Array.from(bodyRow.children).find(td=>{
        const sp = Number(td.getAttribute('colspan')||'1');
        const covers = (idx >= ci) && (idx < ci + sp);
        ci += sp; return covers;
      });
    }
    const rect = (probeCell || handle.parentElement).getBoundingClientRect();
    if(!colEl.style.width){ colEl.style.width = Math.max(40, Math.round(rect.width)) + 'px'; }
    startX = e.clientX;
    startWidth = parseFloat(colEl.style.width) || Math.max(40, Math.round(rect.width));
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}
function enableTextChartColumnResize(root){
  const tbl = (root instanceof Element ? root : document).querySelector('table.chartshell');
  if(!tbl || tbl.dataset.resizable === '1') return;
  expandColgroupsToIndividualCols(tbl);
  addResizeHandles(tbl);
  tbl.dataset.resizable = '1';
    tbl.style.tableLayout = 'fixed';
    tbl.style.width = 'auto';
    tbl.style.maxWidth = '100%';
}
</script>
</body>
</html>