<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FLEx XML Viewer</title>
<style>
  :root{
    --accent:#0b6edb;
    --muted:#6c6c6c;
    --bg:#fbfbfb;
    --card:#fff;
    --border:#e2e2e2;
    --highlight:#fff2b8;
  }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;background:var(--bg);color:#111}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:1.1rem;margin:0}
  textarea{width:720px;max-width:100%;height:220px;font-family:monospace;padding:8px;border:1px solid var(--border);border-radius:6px;background:linear-gradient(#fff,#fcfcfc)}
  input[type=file]{padding:6px}
  button{background:var(--accent);color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#ddd;color:#111}
  .small-btn{padding:4px 8px;font-size:0.85rem;border-radius:6px}
  .viewer{margin-top:18px;background:var(--card);border:1px solid var(--border);padding:14px;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  .controls-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .section-title{font-weight:600;margin:8px 0;font-size:1rem}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  ul.tree li{margin:4px 0;position:relative;padding-left:6px}
  .toggle{user-select:none;cursor:pointer;margin-right:6px;color:var(--accent)}
  .collapsed > ul{display:none}
  .label{font-weight:600;margin-right:6px}
  .muted{color:var(--muted);font-size:0.95rem}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  tr.highlight{background:var(--highlight) !important}
  .natclass{border:1px solid var(--border);padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
  .natclass .members{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .symbol-pill:hover{background:#e8f2ff}
  .small-muted{font-size:0.9rem;color:var(--muted)}
  .translation-main{font-weight:600}
  .translation-others{color:var(--muted);margin-left:6px;font-size:0.95rem}
  .lang-controls{display:flex;align-items:center;gap:8px;margin:6px 0 12px 0;flex-wrap:wrap}
  .lang-controls .lang-item{display:flex;align-items:center;gap:6px;padding:4px}
  .icon-btn{background:#fff;border:1px solid #e0e0e0;padding:5px 7px;border-radius:6px;cursor:pointer}
  .wordform-card{border:1px solid #e6e6e6;padding:10px;border-radius:8px;margin-bottom:8px;background:linear-gradient(#fff,#fcfcff)}
  .wordform-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .wordform-main{font-weight:700;font-size:1.05rem}
  .wordform-meta{color:var(--muted);font-size:0.9rem}
  .wordform-body{margin-top:8px}
  .table-view{width:100%;border-collapse:collapse}
  .table-view th,.table-view td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  .controls-inline{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  footer{margin-top:28px;padding-top:10px;border-top:1px solid #e6e6e6;color:var(--muted);font-size:0.9rem}
</style>
</head>
<body>

<header>
  <h1>FLEx XML Viewer</h1>
  <div style="margin-left:auto" class="small-muted">© 2025 Seth Johnston</div>
</header>

  <section style="background:#eef5ff;border:1px solid #c8dbff;padding:10px 14px;border-radius:8px;margin-bottom:12px">
  <h2 style="font-size:1rem;margin-top:0">About FLEx XML Viewer</h2>
  <p>
    <strong>FLEx XML Viewer</strong> is a client-side web app for viewing and exploring
    <a href="https://software.sil.org/fieldworks/" target="_blank" rel="noopener noreferrer">FieldWorks (FLEx)</a>
    XML exports in a structured, readable format. It runs entirely in your browser and requires no server.
  </p>
  <p>This viewer supports the following FieldWorks export types:</p>
  <ul style="margin-top:4px">
    <li><strong>Lists</strong> — displays hierarchical <code>&lt;list&gt;</code> structures as collapsible nested lists.</li>
    <li><strong>Translated Lists</strong> — handles multilingual <code>&lt;AUni&gt;</code>-based lists with language ordering and visibility controls.</li>
    <li><strong>Phonology</strong> — renders natural classes, phoneme inventories, and cross-references in human-readable tables.</li>
    <li><strong>Wordforms</strong> — displays lexical items and analyses in expandable cards or sortable tables.</li>
    <li><strong>Generic XML</strong> — provides a recursive tree view for any other well-formed XML data.</li>
  </ul>
  <p>
    This app does <em>not</em> process <strong>LIFT</strong> or <strong>FLExText</strong> exports — those should be opened directly in FLEx.
    Discourse XML and Dekereke exports are also outside this tool’s scope:
    see the upcoming <a href="https://github.com/rulingAnts/flet" target="_blank" rel="noopener noreferrer">FLET project</a>
    for tools to view and convert those formats (including an Excel converter for Dekereke).
  </p>
</section>

<textarea id="xmlInput" placeholder="Paste XML here or choose a file..."></textarea>

<div class="controls-row">
  <button id="transformBtn">Transform</button>
  <button id="resetBtn" class="secondary">Reset</button>

  <label style="display:flex;align-items:center;gap:8px" class="small-muted">
    <input id="showNames" type="checkbox"> Show element names
  </label>

  <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
    <input id="fileInput" type="file" accept=".xml,.xml.txt" />
    <button id="openBtn" class="secondary">Open in new window</button>
    <button id="saveBtn" class="secondary">Save as HTML</button>
  </div>
</div>

<div id="viewer" class="viewer" aria-live="polite">
  <div id="renderArea" class="small-muted">Paste or upload an XML file, then click Transform.</div>
</div>

<footer>
  <div>© 2025 Seth Johnston. This software is licensed under the <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" rel="noopener noreferrer">GNU Affero General Public License v3.0 (AGPL-3.0)</a>.</div>
  <div>Portions of this code were generated collaboratively with <strong>ChatGPT (GPT-5)</strong> by OpenAI, under the author’s direction and guidance.</div>
</footer>

<script>
/* ===== Helpers ===== */
const byId = id => document.getElementById(id);
const escapeHtml = s => String(s||'').replace(/[&<>"]/g, c=>'&' + ({'&':'amp','<':'lt','>':'gt','"':'quot'})[c] + ';');
function create(tag, attrs={}, text){
  const el = document.createElement(tag);
  for(const k in attrs){
    if(k==='cls') el.className = attrs[k];
    else el.setAttribute(k, attrs[k]);
  }
  if(text !== undefined && text !== null) el.textContent = text;
  return el;
}

/* ===== Persistence keys and state ===== */
const LANG_PREFS_KEY = 'flex_xml_viewer_lang_prefs_v1';
const WORDFORM_PREFS_KEY = 'flex_xml_viewer_wordform_prefs_v1';

let globalState = {
  phonemeIndex: {},
  idToNatclassIds: {},
  natclassElements: {},
  phonemeRowIds: {},
  showNames: false
};

function saveJSON(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); } catch(e){} }
function loadJSON(key){ try{ const s = localStorage.getItem(key); return s ? JSON.parse(s) : null; } catch(e){ return null; } }

/* ===== File & UI wiring ===== */
byId('fileInput').addEventListener('change', async e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  byId('xmlInput').value = text;
});

byId('resetBtn').addEventListener('click', ()=>{
  byId('xmlInput').value = '';
  byId('renderArea').innerHTML = '<div class="small-muted">Paste or upload an XML file, then click Transform.</div>';
});

byId('transformBtn').addEventListener('click', ()=> {
  const xmlText = byId('xmlInput').value.trim();
  if(!xmlText){ alert('Please paste or upload an XML document first.'); return; }
  try {
    const p = new DOMParser();
    const xmlDoc = p.parseFromString(xmlText, 'application/xml');
    if(xmlDoc.querySelector('parsererror')) throw new Error('XML parse error');
    renderDocument(xmlDoc);
  } catch(err){
    alert('Error parsing XML: ' + err.message);
  }
});

byId('openBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML();
  const w = window.open('', '_blank');
  w.document.write(html);
  w.document.close();
});

byId('saveBtn').addEventListener('click', ()=>{
  const html = buildStandaloneHTML();
  const blob = new Blob([html], {type:'text/html'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'flex_xml_view.html';
  a.click();
  URL.revokeObjectURL(a.href);
});

byId('showNames').addEventListener('change', e=>{
  globalState.showNames = e.target.checked;
  document.querySelectorAll('[data-gen-label]').forEach(el=>{
    const label = el.getAttribute('data-gen-label');
    const prev = el.previousSibling;
    if(prev) prev.textContent = globalState.showNames ? (label + ': ') : '';
  });
});

/* ===== Main detection & dispatch ===== */
function renderDocument(xmlDoc){
  // reset state
  globalState = { phonemeIndex:{}, idToNatclassIds:{}, natclassElements:{}, phonemeRowIds:{}, showNames: byId('showNames').checked };

  const root = xmlDoc.documentElement;
  const tag = root.nodeName.toLowerCase();
  const area = byId('renderArea');
  area.innerHTML = '';

  // Order of detection: Phonology, Translated Lists (AUni multi), Monolingual list, Wordforms, Generic
  if(tag === 'phonology'){
    area.appendChild(renderPhonologyView(xmlDoc));
    return;
  }

  if(tag === 'list' || tag === 'lists'){
    // detect AUni-based multilingual lists
    const aunis = xmlDoc.querySelectorAll('AUni[ws]');
    const langSet = new Set(Array.from(aunis).map(a => a.getAttribute('ws')));
    if(langSet.size > 1){
      area.appendChild(renderTranslatedListView(root, Array.from(langSet)));
      return;
    } else {
      area.appendChild(renderListView(root));
      return;
    }
  }

  // Wordforms detection (FieldWorks uses a <wordforms> root or similar)
  const wfNodes = xmlDoc.getElementsByTagName('wordforms');
  if(wfNodes && wfNodes.length > 0){
    area.appendChild(renderWordformsView(xmlDoc));
    return;
  }

  // fallback generic
  area.appendChild(renderGenericView(root));
}

/* ===== Monolingual List (unchanged behavior) ===== */
function renderListView(root){
  const container = create('div');
  const title = root.querySelector(':scope > name, :scope > Name')?.textContent?.trim() || 'List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  function buildItem(node){
    const li = create('li');
    const hasChildren = node.querySelector(':scope > item') !== null;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '▾' : ' ');
    if(hasChildren) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const name = node.querySelector(':scope > name, :scope > Name')?.textContent?.trim() || node.nodeName;
    const abbr = node.querySelector(':scope > abbr, :scope > Abbreviation')?.textContent?.trim();
    const text = abbr ? `${name} (${abbr})` : name;
    li.appendChild(document.createTextNode(text));

    const childItems = Array.from(node.children).filter(c=>c.nodeName.toLowerCase() === 'item');
    if(childItems.length){
      const ul = create('ul', {cls:'tree'});
      childItems.forEach(ci => ul.appendChild(buildItem(ci)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
      });
    }
    return li;
  }

  const topUL = create('ul', {cls:'tree'});
  const topItems = Array.from(root.children).filter(c => c.nodeName.toLowerCase() === 'item');
  topItems.forEach(it => topUL.appendChild(buildItem(it)));
  container.appendChild(topUL);
  return container;
}

/* ===== Translated (multilingual) List view + Language Controls ===== */
function renderTranslatedListView(root, langList){
  // canonicalize languages (stable order): prefer 'en' if present
  const langs = Array.from(langList);
  langs.sort((a,b)=>{
    if(a.toLowerCase().includes('en') && !b.toLowerCase().includes('en')) return -1;
    if(b.toLowerCase().includes('en') && !a.toLowerCase().includes('en')) return 1;
    return a.localeCompare(b);
  });

  // load saved prefs and merge defaults
  const saved = loadJSON(LANG_PREFS_KEY) || {};
  const prefs = {};
  langs.forEach((ws,i)=> {
    prefs[ws] = {
      ws,
      order: (saved[ws] && typeof saved[ws].order === 'number') ? saved[ws].order : i,
      visible: (saved[ws] && typeof saved[ws].visible === 'boolean') ? saved[ws].visible : true
    };
  });
  // compact orders
  const orderedLangs = Object.values(prefs).sort((a,b)=>a.order-b.order).map(l=>l.ws);
  orderedLangs.forEach((ws,i)=> prefs[ws].order = i);
  saveJSON(LANG_PREFS_KEY, prefs);

  const container = create('div');
  const title = root.querySelector(':scope > Name AUni[ws="en"], :scope > Name AUni, :scope > Name, :scope > name')?.textContent?.trim() || 'Translated List';
  container.appendChild(create('div', {cls:'section-title'}, title));

  const controls = create('div', {cls:'lang-controls'});
  container.appendChild(controls);

  function buildLangControls(){
    controls.innerHTML = '';
    const arr = Object.values(prefs).sort((a,b)=>a.order-b.order);
    arr.forEach((L, idx)=>{
      const item = create('div', {cls:'lang-item'});
      item.style.display = 'flex'; item.style.alignItems = 'center'; item.style.gap = '6px';

      const codeSpan = create('span', {}, L.ws);
      codeSpan.style.fontWeight = '600';
      item.appendChild(codeSpan);

      const up = create('button', {cls:'icon-btn', title:'Move up (higher priority)'}, '⬆️');
      up.addEventListener('click', ()=> { swapOrder(L.ws, -1); });
      item.appendChild(up);

      const down = create('button', {cls:'icon-btn', title:'Move down (lower priority)'}, '⬇️');
      down.addEventListener('click', ()=> { swapOrder(L.ws, +1); });
      item.appendChild(down);

      const vis = create('button', {cls:'icon-btn', title: L.visible ? 'Hide language' : 'Show language'}, L.visible ? '👁️' : '🚫');
      vis.addEventListener('click', ()=> { prefs[L.ws].visible = !prefs[L.ws].visible; saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems(); });
      item.appendChild(vis);

      controls.appendChild(item);
    });

    const reset = create('button', {cls:'small-btn secondary', title:'Reset language order and visibility to defaults'}, 'Reset');
    reset.addEventListener('click', ()=> {
      langs.forEach((ws,i)=> { prefs[ws].order = i; prefs[ws].visible = true; });
      saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
    });
    controls.appendChild(reset);
  }

  const listContainer = create('div');
  container.appendChild(listContainer);

  function renderItems(){
    listContainer.innerHTML = '';
    const ordered = Object.values(prefs).sort((a,b)=>a.order-b.order).filter(l=>l.visible).map(l=>l.ws);
    if(ordered.length === 0){
      listContainer.appendChild(create('div', {cls:'small-muted'}, 'No languages selected. Use controls to show at least one language.'));
      return;
    }
    const poss = root.querySelector(':scope > Possibilities, :scope > possibilities') || root;
    const topItems = Array.from(poss.children).filter(c=>c.nodeType === 1);
    const topUL = create('ul', {cls:'tree'});
    topItems.forEach(ti => topUL.appendChild(buildItem(ti, ordered)));
    listContainer.appendChild(topUL);
  }

  function buildItem(node, visibleLangs){
    const li = create('li');
    const sub = node.querySelector(':scope > SubPossibilities, :scope > SubPossibility, :scope > Possibilities');
    const hasSub = sub && Array.from(sub.children).some(c=>c.nodeType === 1);
    const toggle = create('span', {cls:'toggle'}, hasSub ? '▾' : ' ');
    if(hasSub) toggle.style.cursor = 'pointer';
    li.appendChild(toggle);

    const nameNode = node.querySelector(':scope > Name, :scope > name');
    const abbrNode = node.querySelector(':scope > Abbreviation, :scope > abbr');
    const names = collectAUniMap(nameNode);
    const abbrs = collectAUniMap(abbrNode);
    const inline = create('span');
    inline.innerHTML = buildMultilingualInlineHTML(names, abbrs, visibleLangs);
    li.appendChild(inline);

    if(hasSub){
      const ul = create('ul', {cls:'tree'});
      Array.from(sub.children).filter(c=>c.nodeType===1).forEach(ch => ul.appendChild(buildItem(ch, visibleLangs)));
      li.appendChild(ul);
      toggle.addEventListener('click', ()=> {
        li.classList.toggle('collapsed');
        toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
      });
    }
    return li;
  }

  function swapOrder(ws, delta){
    const entries = Object.values(prefs).sort((a,b)=>a.order-b.order);
    const idx = entries.findIndex(e => e.ws === ws);
    const target = idx + delta;
    if(target < 0 || target >= entries.length) return;
    const a = entries[idx], b = entries[target];
    const t = a.order; a.order = b.order; b.order = t;
    saveJSON(LANG_PREFS_KEY, prefs); buildLangControls(); renderItems();
  }

  buildLangControls();
  renderItems();
  return container;
}

/* ===== Helpers for multilingual lists ===== */
function collectAUniMap(node){
  if(!node) return [];
  const a = Array.from(node.querySelectorAll('AUni'));
  if(a.length) return a.map(x => ({ ws: x.getAttribute('ws') || '', text: x.textContent.trim() }));
  // fallback: Name with ws attribute (mono) or plain text
  if(node.hasAttribute && node.hasAttribute('ws')) return [{ ws: node.getAttribute('ws') || '', text: (node.textContent || '').trim() }];
  const txt = (node.textContent || '').trim();
  return txt ? [{ ws:'', text: txt }] : [];
}

function buildMultilingualInlineHTML(names, abbrs, visibleLangs){
  if(!names || names.length === 0) return '(unnamed)';
  const shown = visibleLangs.map(ws => names.find(n => n.ws === ws)).filter(Boolean);
  if(!shown.length) return '(none)';
  const main = shown[0];
  const others = shown.slice(1);
  let html = `<span class="translation-main">${escapeHtml(main.text)}</span>`;
  if(others.length) html += ' ' + others.map(o => `<span class="translation-others">${escapeHtml(o.text)}</span>`).join(' · ');
  if(abbrs && abbrs.length){
    const abv = visibleLangs.map(ws => (abbrs.find(a => a.ws === ws) || {}).text).filter(Boolean);
    if(abv.length) html += ` <span class="small-muted">[${abv.map(escapeHtml).join(' / ')}]</span>`;
  }
  return html;
}

/* ===== Generic recursive fallback (unchanged) ===== */
function renderGenericView(root){
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Generic XML View'));
  const rootUL = create('ul', {cls:'tree'});
  rootUL.appendChild(build(root));
  container.appendChild(rootUL);
  return container;

  function build(node){
    const li = create('li');
    const childElements = Array.from(node.childNodes).filter(n => n.nodeType === 1 || (n.nodeType === 3 && n.nodeValue.trim()));
    const hasChildren = childElements.length > 0;
    const toggle = create('span', {cls:'toggle'}, hasChildren ? '▾' : ' ');
    if(hasChildren) toggle.style.cursor='pointer';
    li.appendChild(toggle);

    const labelText = node.nodeType === 1 ? node.nodeName : '';
    const labelSpan = create('span');
    if(globalState.showNames && node.nodeType === 1) labelSpan.textContent = labelText + ': ';
    if(globalState.showNames && node.nodeType === 1) labelSpan.style.fontWeight = '600';
    li.appendChild(labelSpan);

    if(node.nodeType === 3){
      li.appendChild(document.createTextNode(node.nodeValue.trim()));
    } else {
      const textChild = Array.from(node.childNodes).filter(n=>n.nodeType===3 && n.nodeValue.trim())[0];
      if(textChild && childElements.every(n => n.nodeType === 3 || (n.nodeType === 1 && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3))){
        li.appendChild(create('span', {}, textChild.nodeValue.trim()));
      } else {
        const subUL = create('ul', {cls:'tree'});
        childElements.forEach(ch => subUL.appendChild(build(ch)));
        li.appendChild(subUL);
        if(hasChildren){
          toggle.addEventListener('click', ()=> {
            li.classList.toggle('collapsed');
            toggle.textContent = toggle.textContent === '▾' ? '▸' : '▾';
          });
        }
      }
    }
    if(node.nodeType === 1) li.setAttribute('data-gen-label', node.nodeName);
    return li;
  }
}

/* ===== Phonology rendering (human-friendly) ===== */
function renderPhonologyView(xmlDoc){
  const root = xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Phonology Summary'));
  container.appendChild(create('div', {cls:'small-muted'}, `Version ${root.getAttribute('Version') || '—'} — DefaultVernWs: ${root.getAttribute('DefaultVernWs') || '—'}`));

  // index phonemes
  globalState.phonemeIndex = {};
  const phonemes = Array.from(xmlDoc.getElementsByTagName('PhPhoneme') || []);
  phonemes.forEach(p => {
    const id = p.getAttribute('Id');
    const symbol = pickAUni(p.querySelector(':scope > Name')) || '';
    const desc = p.querySelector(':scope > Description Run')?.textContent?.trim() || '';
    const codes = Array.from(p.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a => a.textContent.trim()).filter(Boolean);
    globalState.phonemeIndex[id] = { id, symbol, desc, codes, node: p };
  });

  // phoneme sets / inventory
  const sets = Array.from(xmlDoc.getElementsByTagName('PhPhonemeSet') || []);
  sets.forEach(set => {
    const setName = pickAUni(set.querySelector(':scope > Name')) || 'Phoneme Set';
    const setDiv = create('div', {cls:'natclass'});
    setDiv.appendChild(create('div', {cls:'section-title'}, setName));
    const setDesc = set.querySelector(':scope > Description Run')?.textContent;
    if(setDesc) setDiv.appendChild(create('div', {cls:'small-muted'}, setDesc));

    const table = create('table', {cls:'phonemes'});
    table.innerHTML = '<thead><tr><th>Symbol</th><th>Description</th><th>ID</th><th>Codes</th></tr></thead>';
    const tbody = create('tbody');
    const rows = Array.from(set.querySelectorAll(':scope > Phonemes PhPhoneme')) || phonemes;
    rows.forEach(pnode => {
      const pid = pnode.getAttribute('Id');
      const data = globalState.phonemeIndex[pid] || {
        id: pid,
        symbol: pickAUni(pnode.querySelector(':scope > Name')) || '',
        desc: pnode.querySelector(':scope > Description Run')?.textContent || '',
        codes: Array.from(pnode.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim())
      };
      const row = create('tr', {id: 'phoneme-row-' + data.id});
      const symbolCell = create('td');
      const symBtn = create('span', {cls:'symbol-pill'}, data.symbol || '(no symbol)');
      symBtn.style.cursor = 'pointer';
      symBtn.addEventListener('click', ()=> onPhonemeSymbolClick(data.id));
      symbolCell.appendChild(symBtn);
      row.appendChild(symbolCell);
      row.appendChild(create('td', {}, data.desc || ''));
      row.appendChild(create('td', {}, data.id));
      row.appendChild(create('td', {}, (data.codes && data.codes.join(', ')) || ''));
      tbody.appendChild(row);
      globalState.phonemeRowIds[data.id] = row.id;
    });
    table.appendChild(tbody);
    setDiv.appendChild(table);

    // boundary markers
    const bMarkers = Array.from(set.querySelectorAll(':scope > BoundaryMarkers PhBdryMarker')) || [];
    if(bMarkers.length){
      setDiv.appendChild(create('div', {cls:'section-title'}, 'Boundary Markers'));
      const bmList = create('div', {cls:'small-muted'});
      bMarkers.forEach(bm => {
        const bmName = pickAUni(bm.querySelector(':scope > Name')) || bm.getAttribute('Id') || '';
        const bmCodes = Array.from(bm.querySelectorAll(':scope > Codes PhCode Representation AUni')).map(a=>a.textContent.trim()).filter(Boolean);
        bmList.appendChild(create('div', {}, `${bmName} ${ bmCodes.length ? '(' + bmCodes.join(', ') + ')' : ''}`));
      });
      setDiv.appendChild(bmList);
    }

    container.appendChild(setDiv);
  });

  // natural classes
  const ncs = Array.from(xmlDoc.getElementsByTagName('PhNCSegments') || []);
  if(ncs.length){
    container.appendChild(create('div', {cls:'section-title'}, 'Natural Classes'));
    ncs.forEach((nc, idx) => {
      const ncId = nc.getAttribute('Id') || ('nc-' + idx);
      const name = pickAUni(nc.querySelector(':scope > Name')) || nc.getAttribute('Id') || 'Unnamed';
      const abbr = pickAUni(nc.querySelector(':scope > Abbreviation')) || '';
      const desc = nc.querySelector(':scope > Description Run')?.textContent || '';
      const ncEl = create('div', {cls:'natclass', id: 'natclass-' + ncId});
      const title = create('div', {cls:'section-title'}, name + (abbr ? (' (' + abbr + ')') : ''));
      ncEl.appendChild(title);
      if(desc) ncEl.appendChild(create('div', {cls:'small-muted'}, desc));
      const segments = Array.from(nc.querySelectorAll(':scope > Segments')).map(s => s.getAttribute('dst')).filter(Boolean);
      const membersDiv = create('div', {cls:'members'});
      segments.forEach(sid => {
        const phon = globalState.phonemeIndex[sid];
        const text = phon ? (phon.symbol || phon.id) : sid;
        const pill = create('span', {cls:'symbol-pill'}, text);
        pill.addEventListener('click', ()=> {
          if(globalState.phonemeRowIds[sid]) scrollToAndHighlight(globalState.phonemeRowIds[sid]);
          else alert('Phoneme ID ' + sid + ' not found in phoneme index.');
        });
        membersDiv.appendChild(pill);
        if(!globalState.idToNatclassIds[sid]) globalState.idToNatclassIds[sid] = [];
        globalState.idToNatclassIds[sid].push(ncEl.id);
      });
      ncEl.appendChild(membersDiv);
      container.appendChild(ncEl);
      globalState.natclassElements[ncEl.id] = ncEl;
    });
  }

  // simple placeholders for Environments, Contexts, Rules
  const envs = Array.from(xmlDoc.getElementsByTagName('Environments') || []);
  envs.forEach(en => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Environments'));
    sec.appendChild(en.hasChildNodes() ? renderGenericView(en) : create('div', {cls:'small-muted'}, '(no environment definitions)'));
    container.appendChild(sec);
  });
  const ctxs = Array.from(xmlDoc.getElementsByTagName('Contexts') || []);
  ctxs.forEach(c => {
    const sec = create('div', {cls:'natclass'});
    sec.appendChild(create('div', {cls:'section-title'}, 'Contexts'));
    sec.appendChild(c.hasChildNodes() ? renderGenericView(c) : create('div', {cls:'small-muted'}, '(no contexts defined)'));
    container.appendChild(sec);
  });

  // interactive behavior: clicking phoneme rows highlights natural classes
  Object.keys(globalState.phonemeRowIds).forEach(pid => {
    const rid = globalState.phonemeRowIds[pid];
    const row = document.getElementById(rid);
    if(row){
      row.addEventListener('click', ()=> {
        const natIds = globalState.idToNatclassIds[pid] || [];
        Object.values(globalState.natclassElements).forEach(el=> el.style.boxShadow = '');
        if(natIds.length){
          natIds.forEach(nid => {
            const el = globalState.natclassElements[nid];
            if(el){
              el.style.boxShadow = '0 0 0 3px rgba(11,110,219,0.08)';
              el.scrollIntoView({behavior:'smooth', block:'center'});
            }
          });
        } else {
          row.classList.add('highlight');
          setTimeout(()=> row.classList.remove('highlight'), 1200);
        }
      });
    }
  });

  return container;
}

/* ===== Wordforms export rendering (Card + Table + gloss language controls) ===== */
function renderWordformsView(xmlDoc){
  // root might be <wordforms> or something similar depending on export
  const root = xmlDoc.getElementsByTagName('wordforms')[0] || xmlDoc.documentElement;
  const container = create('div');
  container.appendChild(create('div', {cls:'section-title'}, 'Wordforms'));

  // collect all wordform nodes
  // FieldWorks samples may use <wordform> children
  const wfNodes = Array.from(root.getElementsByTagName('wordform'));
  // fallback: maybe root contains <Wordform> nodes
  if(wfNodes.length === 0){
    const alt = Array.from(root.getElementsByTagName('WordForm')).concat(Array.from(root.getElementsByTagName('Wordform')));
    if(alt.length) wfNodes.push(...alt);
  }

  // scan for gloss languages across all gloss elements
  const glossElems = Array.from(xmlDoc.querySelectorAll('gloss[ws], gloss AUni[ws], glosses gloss[ws]')) // flexible
    .concat(Array.from(xmlDoc.querySelectorAll('gloss'))); // fallback
  const glossLangsSet = new Set();
  glossElems.forEach(g => {
    if(g.getAttribute && g.getAttribute('ws')) glossLangsSet.add(g.getAttribute('ws'));
    else {
      // also accept <gloss><AUni ws="..."> or similar
      const auni = g.querySelector && g.querySelector('AUni[ws]');
      if(auni) glossLangsSet.add(auni.getAttribute('ws'));
    }
  });
  const glossLangs = Array.from(glossLangsSet);
  glossLangs.sort((a,b)=> a.toLowerCase().includes('en')? -1 : a.localeCompare(b));

  // load wordform prefs (view mode + gloss languages visibility)
  const saved = loadJSON(WORDFORM_PREFS_KEY) || {};
  let viewMode = saved.viewMode || 'card'; // 'card' or 'table'
  let glossPrefs = saved.glossPrefs || {};
  // init prefs from discovered glossLangs
  glossLangs.forEach((ws,i) => {
    if(typeof glossPrefs[ws] !== 'object') glossPrefs[ws] = { ws, visible: true, order: i };
  });

  // UI controls
  const controls = create('div', {cls:'controls-inline'});
  const viewToggle = create('button', {cls:'small-btn', title:'Toggle Card/Table view'}, viewMode === 'card' ? 'Switch to Table View 📋' : 'Switch to Card View 🗂️');
  controls.appendChild(viewToggle);

  // gloss language chooser (only shown in Table view)
  const glossChooser = create('div', {cls:'small-muted'});
  glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
  glossChooser.style.paddingLeft = '8px';
  glossChooser.style.marginLeft = '8px';
  glossChooser.textContent = 'Gloss languages: ';
  glossLangs.forEach(ws => {
    const label = create('label');
    label.style.marginRight = '8px';
    const cb = create('input'); cb.type = 'checkbox'; cb.checked = glossPrefs[ws].visible; cb.dataset.ws = ws;
    cb.addEventListener('change', () => {
      glossPrefs[ws].visible = cb.checked; saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); renderItems();
    });
    label.appendChild(cb);
    label.appendChild(document.createTextNode(' ' + ws));
    glossChooser.appendChild(label);
  });

  controls.appendChild(glossChooser);
  container.appendChild(controls);

  // search/filter input (helpful)
  const searchRow = create('div', {cls:'small-muted'});
  searchRow.style.marginTop = '8px';
  searchRow.innerHTML = 'Filter: <input id="wf_search" placeholder="search form or gloss..." style="padding:4px;border-radius:4px;border:1px solid #ddd;margin-left:6px;">';
  container.appendChild(searchRow);

  const listArea = create('div');
  listArea.style.marginTop = '8px';
  container.appendChild(listArea);

  // wire view toggle
  viewToggle.addEventListener('click', ()=>{
    viewMode = viewMode === 'card' ? 'table' : 'card';
    saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs });
    viewToggle.textContent = viewMode === 'card' ? 'Switch to Table View 📋' : 'Switch to Card View 🗂️';
    glossChooser.style.display = viewMode === 'table' ? 'block' : 'none';
    renderItems();
  });

  // render items either card or table
  function renderItems(){
    listArea.innerHTML = '';
    const q = (byId('wf_search')?.value || '').trim().toLowerCase();

    // helper to collect form text, glosses, category, counts
    function extractData(wf){
      const forms = [];
      // FieldWorks uses <form ws="..."> inside wordform — but samples vary. We'll be flexible.
      const formNodes = Array.from(wf.querySelectorAll('form, Form, word'));
      if(formNodes.length === 0){
        // try direct text
        const txt = (wf.textContent || '').trim();
        if(txt) forms.push({ws:'', text: txt});
      } else {
        formNodes.forEach(fn => {
          // look for AUni children if present
          const aunis = fn.querySelectorAll && fn.querySelectorAll('AUni');
          if(aunis && aunis.length){
            aunis.forEach(a => forms.push({ ws: a.getAttribute('ws') || '', text: (a.textContent||'').trim() }));
          } else {
            const ws = fn.getAttribute && fn.getAttribute('ws') || '';
            const t = (fn.textContent || '').trim();
            if(t) forms.push({ ws, text: t });
          }
        });
      }

      // analyses -> gloss, category, counts
      const analyses = Array.from(wf.querySelectorAll('analysis, Analysis'));
      const glosses = []; // array of {ws,text}
      const categories = [];
      analyses.forEach(a => {
        const gNodes = Array.from(a.querySelectorAll('gloss, Gloss'));
        if(gNodes.length){
          gNodes.forEach(gn => {
            const aun = gn.querySelector && gn.querySelector('AUni[ws]');
            if(aun) glosses.push({ ws: aun.getAttribute('ws') || '', text: (aun.textContent||'').trim() });
            else {
              const ws = gn.getAttribute && gn.getAttribute('ws') || '';
              const t = (gn.textContent || '').trim();
              if(t) glosses.push({ ws, text: t });
            }
          });
        }
        const cat = a.querySelector('category, Category')?.textContent?.trim();
        if(cat) categories.push(cat);
      });

      // counts
      const predicted = parseInt(wf.getAttribute('PredictedAnalyses') || wf.getAttribute('predictedanalyses') || wf.querySelector('PredictedAnalyses')?.textContent || '0') || 0;
      const user = parseInt(wf.getAttribute('UserAnalyses') || wf.getAttribute('useranalyses') || wf.querySelector('UserAnalyses')?.textContent || '0') || 0;

      return { forms, glosses, categories, predicted, user, node: wf };
    }

    const dataList = wfNodes.map(wf => extractData(wf));

    // apply search filter: matches form text or any gloss text
    const filtered = dataList.filter(d => {
      if(!q) return true;
      const formMatch = d.forms.some(f => (f.text||'').toLowerCase().includes(q));
      const glossMatch = d.glosses.some(g => (g.text||'').toLowerCase().includes(q));
      const catMatch = d.categories.some(c => (c||'').toLowerCase().includes(q));
      return formMatch || glossMatch || catMatch;
    });

    if(viewMode === 'card'){
      // Card view
      filtered.forEach(d => {
        const card = create('div', {cls:'wordform-card'});
        const header = create('div', {cls:'wordform-header'});
        const main = create('div');
        const primaryForm = d.forms[0]?.text || '(no form)';
        main.appendChild(create('div', {cls:'wordform-main'}, primaryForm));
        main.appendChild(create('div', {cls:'wordform-meta'}, `Predicted: ${d.predicted} · User: ${d.user}`));
        header.appendChild(main);
        // small expand button (collapse/expand body)
        const expBtn = create('button', {cls:'small-btn', title:'Toggle details'}, '▾');
        header.appendChild(expBtn);
        card.appendChild(header);

        const body = create('div', {cls:'wordform-body'});
        if(d.glosses.length === 0 && d.categories.length === 0){
          body.appendChild(create('div', {cls:'small-muted'}, '— No analysis —'));
        } else {
          // group glosses by ws
          const byWs = {};
          d.glosses.forEach(g => { if(!byWs[g.ws]) byWs[g.ws] = []; byWs[g.ws].push(g.text); });
          Object.keys(byWs).forEach(ws => {
            const line = create('div');
            line.innerHTML = `<strong>Gloss (${escapeHtml(ws)}):</strong> ${escapeHtml(byWs[ws].join('; '))}`;
            body.appendChild(line);
          });
          if(d.categories.length){
            body.appendChild(create('div', {}, `Category: ${escapeHtml(d.categories.join('; '))}`));
          }
        }
        body.style.display = 'block';
        expBtn.addEventListener('click', ()=> {
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
          expBtn.textContent = expBtn.textContent === '▾' ? '▸' : '▾';
        });
        card.appendChild(body);
        listArea.appendChild(card);
      });
    } else {
      // Table view: show selected gloss columns based on glossPrefs
      const visibleGlossLangs = glossLangs.filter(ws => glossPrefs[ws] && glossPrefs[ws].visible);
      const table = create('table', {cls:'table-view'});
      // build header
      const thead = create('thead');
      const headerRow = create('tr');
      headerRow.appendChild(create('th', {}, 'Wordform'));
      visibleGlossLangs.forEach(ws => headerRow.appendChild(create('th', {}, `Gloss (${ws})`)));
      headerRow.appendChild(create('th', {}, 'Category'));
      headerRow.appendChild(create('th', {}, 'Pred'));
      headerRow.appendChild(create('th', {}, 'User'));
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = create('tbody');
      filtered.forEach(d => {
        const tr = create('tr');
        const primaryForm = d.forms[0]?.text || '(no form)';
        tr.appendChild(create('td', {}, primaryForm));
        visibleGlossLangs.forEach(ws => {
          const text = d.glosses.filter(g=>g.ws === ws).map(g=>g.text).join('; ') || '—';
          tr.appendChild(create('td', {}, text));
        });
        tr.appendChild(create('td', {}, d.categories.join('; ') || '—'));
        tr.appendChild(create('td', {}, String(d.predicted)));
        tr.appendChild(create('td', {}, String(d.user)));
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      listArea.appendChild(table);
    }
  }

  // initial render
  renderItems();

  // wire search input
  const searchInput = byId('wf_search');
  if(searchInput){
    searchInput.addEventListener('input', () => { renderItems(); });
  }

  // wire gloss chooser UI to persist prefs
  // already wired by checkboxes earlier when created, but ensure persistence for viewMode state
  // save viewMode & glossPrefs whenever changed
  function persistWordformPrefs(){ saveJSON(WORDFORM_PREFS_KEY, { viewMode, glossPrefs }); }
  // update glossPrefs reference to the variable used by event handlers above
  // ensure glossPrefs is synced with UI checkbox states if user toggles view toggle
  // done through event handlers above that call saveJSON directly.

  return container;
}

/* ===== Utilities used by phonology rendering ===== */
function pickAUni(node){
  if(!node) return '';
  const aunis = Array.from(node.querySelectorAll('AUni'));
  if(aunis.length === 0) {
    const t = node.textContent && node.textContent.trim();
    return t || '';
  }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('fau')) return a.textContent.trim(); }
  for(const a of aunis){ const ws = (a.getAttribute('ws')||'').toLowerCase(); if(ws.includes('en')) return a.textContent.trim(); }
  return aunis[0].textContent.trim();
}

/* ===== Click helpers ===== */
function onPhonemeSymbolClick(phonId){
  const rowId = globalState.phonemeRowIds[phonId];
  if(!rowId){ alert('Phoneme entry not found: ' + phonId); return; }
  scrollToAndHighlight(rowId);
}
function scrollToAndHighlight(rowId){
  const el = document.getElementById(rowId);
  if(!el) return;
  document.querySelectorAll('tr.highlight').forEach(r=> r.classList.remove('highlight'));
  el.classList.add('highlight');
  el.scrollIntoView({behavior:'smooth', block:'center'});
  el.classList.add('scroll-target');
  setTimeout(()=> el.classList.remove('scroll-target'), 2200);
}

/* ===== Build standalone HTML (for open/save) — note escaped closing tag to avoid template literal issues ===== */
function buildStandaloneHTML(){
  const render = byId('renderArea');
  const content = render.innerHTML;
  const doc = `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>FLEx XML View Export</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:18px;color:#111;background:#fbfbfb}
  .toggle{cursor:pointer;color:#0b6edb;margin-right:6px}
  ul.tree{list-style:none;margin:6px 0 6px 14px;padding-left:10px;border-left:1px dotted #ddd}
  .collapsed > ul{display:none}
  .symbol-pill{background:#f1f8ff;border:1px solid #d6eaff;padding:3px 7px;border-radius:6px;cursor:pointer}
  .highlight{background: #fff2b8}
  table.phonemes{width:100%;border-collapse:collapse;margin-top:8px}
  table.phonemes th, table.phonemes td{padding:8px;border-bottom:1px solid #eee;text-align:left}
  .natclass{border:1px solid #e2e2e2;padding:8px;border-radius:6px;margin-bottom:10px;background:linear-gradient(#fff,#f9f9f9)}
</style>
</head>
<body>
${content}
<script>
  document.querySelectorAll('.toggle').forEach(t=> {
    const parent = t.parentElement;
    t.addEventListener('click', ()=> {
      parent.classList.toggle('collapsed');
      t.textContent = t.textContent === '▾' ? '▸' : '▾';
    });
  });
  document.querySelectorAll('.symbol-pill').forEach(p=> {
    p.addEventListener('click', ()=> {
      const txt = p.textContent.trim();
      const rows = document.querySelectorAll('table.phonemes tbody tr');
      for(const r of rows){
        if(r.cells[0] && r.cells[0].textContent.trim() === txt){
          r.scrollIntoView({behavior:'smooth', block:'center'});
          r.classList.add('highlight');
          setTimeout(()=> r.classList.remove('highlight'), 1800);
          return;
        }
      }
    });
  });
<\/script>
</body>
</html>`;
  return doc;
}
</script>
</body>
</html>