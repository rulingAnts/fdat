<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Upload Chart XML â†’ HTML table</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 1.5em; }
    #output { margin-top: 1em; }
  </style>
</head>
<body>
  <h1>Upload a Chart XML</h1>
  <p>Select your FLEx/FieldWorks chart XML file (e.g. <code>DiscourseChartSet1a.xml</code>), and this page will apply the hosted XSLT to render a table.</p>

  <input type="file" id="xmlFile" accept=".xml,text/xml"/>
  <div id="status"></div>
  <div id="output"></div>

<script>
  // Automatically add a cache-busting parameter (timestamp) to force GitHub Pages/CDN refreshes.
  // You can also replace this with a manual version string if you prefer predictable URLs.
  function cacheBust(url) {
    const ts = new Date().toISOString().replace(/[-:.TZ]/g, "");
    const sep = url.includes("?") ? "&" : "?";
    return `${url}${sep}v=${ts}`;
  }

  async function loadXSL() {
    // Load the newer stylesheet with colgroup logic
    const url = cacheBust("textchart-to-html.xsl");
    const resp = await fetch(url);
    if (!resp.ok) throw new Error("Failed to fetch XSL: " + resp.status);
    const txt = await resp.text();
    const doc = new DOMParser().parseFromString(txt, "text/xml");
    const xslErr = doc.getElementsByTagName("parsererror")[0];
    if (xslErr) {
      throw new Error("XSL parse error: " + xslErr.textContent.trim());
    }
    return doc;
  }

  async function handleFile(e) {
    const file = e.target.files[0];
    if (!file) return;
    document.getElementById("status").textContent = "Loading XSL...";
    try {
      const [xslDoc, xmlText] = await Promise.all([
        loadXSL(),
        file.text()
      ]);
      document.getElementById("status").textContent = "Parsing XML...";
      const xmlDoc = new DOMParser().parseFromString(xmlText, "text/xml");
      const xmlErr = xmlDoc.getElementsByTagName("parsererror")[0];
      if (xmlErr) {
        throw new Error("XML parse error: " + xmlErr.textContent.trim());
      }

      if (!window.XSLTProcessor) {
        document.getElementById("status").textContent = "XSLTProcessor not supported in this browser.";
        return;
      }

      const proc = new XSLTProcessor();
      proc.importStylesheet(xslDoc);
      const frag = proc.transformToFragment(xmlDoc, document);
      const out = document.getElementById("output");
      out.innerHTML = "";
      out.appendChild(frag);
      document.getElementById("status").textContent = "Rendered successfully.";
    } catch (err) {
      const status = document.getElementById("status");
      status.textContent = "Error: " + (err && err.message ? err.message : String(err));
      console.error("Transform error", err);
    }
  }

  document.getElementById("xmlFile").addEventListener("change", handleFile);
</script>
</body>
</html>